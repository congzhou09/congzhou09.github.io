<!DOCTYPE html><html><head><meta charset="utf-8"><title>Babel相关内容串联 | Congzhou&#39;s Blog</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Babel"><meta name="description" content="基本概念● Babel 是个 JS 编译器，与大多数编译器一样，包含“parsing”、“transforming”、“generation”三个处理阶段。如下图所示，代码首先经由 @babel&#x2F;parser(曾用名 Babylon) 解析成抽象语法树(AST)，然后对 AST 做遍历(@babel&#x2F;traverse)和转换(各种@babel&#x2F;plugin-..)，最"><meta property="og:type" content="article"><meta property="og:title" content="Babel相关内容串联"><meta property="og:url" content="https://congzhou09.github.io/knowledge/Babel%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%E4%B8%B2%E8%81%94.html"><meta property="og:site_name" content="Congzhou&#39;s Blog"><meta property="og:description" content="基本概念● Babel 是个 JS 编译器，与大多数编译器一样，包含“parsing”、“transforming”、“generation”三个处理阶段。如下图所示，代码首先经由 @babel&#x2F;parser(曾用名 Babylon) 解析成抽象语法树(AST)，然后对 AST 做遍历(@babel&#x2F;traverse)和转换(各种@babel&#x2F;plugin-..)，最"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://congzhou09.github.io/knowledge/Babel%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%E4%B8%B2%E8%81%94/babel_procedure.jpg"><meta property="article:published_time" content="2020-10-07T14:51:48.000Z"><meta property="article:modified_time" content="2025-03-19T13:37:34.608Z"><meta property="article:author" content="Congzhou"><meta property="article:tag" content="Babel"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://congzhou09.github.io/knowledge/Babel%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%E4%B8%B2%E8%81%94/babel_procedure.jpg"><link rel="alternate" type="application/atom+xml" title="Congzhou&#39;s Blog" href="/atom.xml"><link rel="shortcut icon" href="/tiger.ico"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/lib/fancybox.css"><script>window.lazyScripts=[]</script><script src="/js/av-min.js"></script><script src="/js/util.min.js"></script><script src="/js/fancybox.umd.js"></script><meta name="generator" content="Hexo 7.2.0"></head><body><script>var VISIT_INFO={};defineObserveKey(VISIT_INFO,"totalPV"),defineObserveKey(VISIT_INFO,"curPagePV"),defineObserveKey(VISIT_INFO,"totalUV")</script><div id="loading" class="active"></div><aside id="menu"><div class="inner flex-row-vertical"><div class="brand-wrap"><img class="brand-wrap-img" finalsrc="/img/brand.jpg" src="/img/brand-loading.jpg" alt="brandBackground"><div class="brand"><a href="/" class="avatar waves-effect waves-circle waves-light"><img finalsrc="/img/avatar.jpg" src="/img/avatar-loading.jpg" style="width:100%" alt="avatar"></a><hgroup class="introduce"><div class="nickname" style="margin-left:5px">Congzhou</div><div class="mail"><span class="iconfont icon-youxiang" style="vertical-align:middle"></span><span>congzhou09@gmail.com</span></div><div class="github-link"><a target="_blank" href="https://github.com/congzhou09"><span class="iconfont icon-ic-github"></span>GitHub主页</a></div></hgroup><div class="hint-container"></div></div></div><div class="scroll-wrap flex-col"><ul class="nav"><li class="waves-block waves-effect"><a href="/"><i class="iconfont icon icon-home" style="font-size:24px"></i>主页</a></li><li class="waves-block waves-effect"><a href="/archives"><i class="iconfont icon icon-archive" style="font-size:24px"></i>归档</a></li><li class="waves-block waves-effect"><a href="/tags"><i class="iconfont icon icon-tags" style="font-size:24px"></i>标签</a></li><li class="waves-block waves-effect"><a href="/categories"><i class="iconfont icon icon-categoryselected" style="font-size:24px"></i>分类</a></li></ul></div></div></aside><main id="main"><header class="top-header" id="header"><div class="flex-row"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" style="text-decoration:none" id="menu-toggle"><span class="iconfont icon-menu" style="font-size:21px;font-weight:700"></span></a><div class="flex-col header-title ellipsis">Babel相关内容串联</div><div class="search-wrap" id="search-wrap"><input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" style="text-decoration:none" id="search"><span class="iconfont icon-search" style="font-size:24px;font-weight:700"></span></a></div></div></header><header class="content-header post-header"><div class="container fade-scale"><h2 class="title">Babel相关内容串联</h2><h5 class="subtitle"><time datetime="2020-10-07T14:51:48.000Z" itemprop="datePublished" class="page-time">2020-10-07</time><ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/knowledge/">知识解惑</a></li></ul></h5></div></header><div class="container body-wrap"><aside class="post-widget"><nav class="post-toc-wrap" id="post-toc"><h4>目录</h4><ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="post-toc-number">1.</span><span class="post-toc-text">基本概念</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BD%BF%E7%94%A8-Babel-%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="post-toc-number">2.</span><span class="post-toc-text">使用 Babel 的方式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#babel-preset-env"><span class="post-toc-number">3.</span><span class="post-toc-text">@babel&#x2F;preset-env</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#babel-preset-env-%E7%9A%84%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E9%A1%B9"><span class="post-toc-number">3.1.</span><span class="post-toc-text">@babel&#x2F;preset-env 的常用配置项</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#polyfill"><span class="post-toc-number">4.</span><span class="post-toc-text">polyfill</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#babel-polyfill"><span class="post-toc-number">4.1.</span><span class="post-toc-text">@babel&#x2F;polyfill</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#babel-runtime"><span class="post-toc-number">4.2.</span><span class="post-toc-text">@babel&#x2F;runtime</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BB%8E%E6%89%93%E5%8C%85%E5%86%85%E5%AE%B9%E7%9C%8B-polyfill-%E6%96%B9%E5%BC%8F%E4%B8%8E-runtime-%E6%96%B9%E5%BC%8F%E5%8C%BA%E5%88%AB"><span class="post-toc-number">4.3.</span><span class="post-toc-text">从打包内容看 polyfill 方式与 runtime 方式区别</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Babel-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="post-toc-number">5.</span><span class="post-toc-text">Babel 配置文件</span></a></li></ol></nav></aside><article id="post-Babel相关内容串联" class="post-article article-type-post fade" itemprop="blogPost"><div class="post-card"><h1 class="post-card-title">Babel相关内容串联</h1><div class="post-meta"><time class="post-time" title="2020-10-07 22:51:48" datetime="2020-10-07T14:51:48.000Z" itemprop="datePublished">2020-10-07</time><ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/knowledge/">知识解惑</a></li></ul><span id="container_page_pv" title="文章总阅读量" style="display:none"><span class="iconfont icon-eye" style="margin-right:5px;font-size:12px"></span><span id="value_page_pv"></span></span></div><div class="post-content" id="post-content" itemprop="postContent"><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>● Babel 是个 JS 编译器，与大多数编译器一样，包含“parsing”、“transforming”、“generation”三个处理阶段。如下图所示，代码首先经由 @babel&#x2F;parser(曾用名 Babylon) 解析成抽象语法树(AST)，然后对 AST 做遍历(@babel&#x2F;traverse)和转换(各种@babel&#x2F;plugin-..)，最后根据转换后的 AST 生成新的常规 JS 代码(@babel&#x2F;generator)。</p><div class="img-container" style="width:90%"><img src="/knowledge/Babel%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%E4%B8%B2%E8%81%94/babel_procedure.jpg" class="" onerror="imgOnError(this)" data-fancybox></div><p>● Babel 本身可看作是个流水线空盒子，每个阶段具体处理过程是通过各种插件(plugin)实现的，通过配置不同的插件组合达到不同的处理目的。<br>● Babel 的<strong>plugin</strong>有两类：<br>（1）Syntax Plugins(语法插件)，用于使 babel 支持对特定语法的 parse。<br>（2）Transform Plugins(转译插件)，用于 transforming 阶段的插件，此类插件包含了 parse 阶段相关的 Syntax Plugin 并会在代码转译为目标等级代码期间自动使用它们。<br>● 如果仅编译小范围内容，可以通过仅引入对应的 plugin 实现。更常见的方式是使用<strong>presets(预设)</strong>，它是为特定目的预置的一组 plugin 的集合。<br>● 根据不同转换目的，常见的 presets 如下，<strong>本文主要面向转换 ES 语法的场景</strong>。<br>（1）用于转换 ES 语法的 @babel&#x2F;preset-env。<br>（2）用于转换 React 语法的 @babel&#x2F;preset-react。这个 preset 中包含的最著名插件是用于转换 JSX 语法的 @babel&#x2F;plugin-transform-react-jsx。<br>（3）用于转换 TypeScript 语法的@babel&#x2F;preset-typescript。<br>● preset 及 plugin 的使用，除了 npm 安装，还需要通过 Babel 配置文件(如“.babelrc”)配置，配置内容是个对象，对象格式示例如下，对象属性字段 &quot;presets&quot; 和 &quot;plugins&quot; 的取值分别是个数组，数组内容是具体 preset 或 plugin 名称的字符串，而当 preset 或 plugin 也要有自己的 options 时就使用数组表示，数组第一个元素是 preset 或 plugin 名称的字符串，第二个元素是对应的 options 对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    [</span><br><span class="line">      &quot;@babel/preset-env&quot;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;modules&quot;: false,</span><br><span class="line">        &quot;useBuiltIns&quot;: &quot;usage&quot;,</span><br><span class="line">        &quot;corejs&quot;: 3,</span><br><span class="line">        &quot;targets&quot;: &#123;</span><br><span class="line">          &quot;safari&quot;: &quot;6&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  &quot;plugins&quot;: [&quot;@babel/plugin-external-helpers&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>● 配置多个 preset 与 plugin 情况下的执行顺序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）总体先执行 Plugin 再执行 Preset ，与二者声明次序无关。</span><br><span class="line">（2）多个Plugin 按照声明次序顺序执行。</span><br><span class="line">（3）多个Preset 按照声明次序逆序执行。</span><br></pre></td></tr></table></figure><p>● ES 的转换通常指从 ES 高版本转换到低版本，从而让新的 ES 代码能在老版本的 ES 环境中运行。这里要转换的内容包含两类：新语法和新特性。新语法指的是 class、import&#x2F;export、箭头函数、const、对象解构这类原有特性的新写法。新特性指的是原来版本不存在的特性，如 Promise、async&#x2F;await、Array.prototype.includes()。对新语法支持在 @babel&#x2F;preset-env 里，对新特性的支持在统称为 polyfill 的库中(具体是 @babel&#x2F;runtime 等，详见下文)。通过合理配置，@babel&#x2F;preset-env 会在解析转换过程中引入 polyfill 的内容。</p><p>● TypeScript 通过配置 target 字段也支持 ES 的语法转换，但不支持 polyfill 的自动添加。</p><h3 id="使用-Babel-的方式"><a href="#使用-Babel-的方式" class="headerlink" title="使用 Babel 的方式"></a>使用 Babel 的方式</h3><p>◇ 可以通过以下三种方式使用 Babel 做编译处理<br>（1）通过 @babel&#x2F;cli(曾用名 babel-cli)使用&quot;babel&quot;命令执行。<br>（2）通过 webpack(babel-loader)和 rollup(@rollup&#x2F;plugin-babel)等打包或编译工具调用。<br>（3）通过 @babel&#x2F;register(曾用名 babel-register)为 Node.js 的 require 函数增加钩子，以在运行时调用 require 加载.es6, .es, .jsx 和.js 类型文件的时候先用 babel 进行转码处理，由于是实时转码更适合在 Node.js 开发环境使用。<br>◇ 无论使用哪种方式，都要先安装@babel&#x2F;core 和提供 Babel 配置文件。</p><h3 id="babel-preset-env"><a href="#babel-preset-env" class="headerlink" title="@babel&#x2F;preset-env"></a>@babel&#x2F;preset-env</h3><p>◆ Babel 官方推荐使用 @babel&#x2F;preset-env(曾用名 babel-preset-env，曾经的 babel-preset-es2015 和 babel-preset-es2016 以及 babel-preset-es2017 等特定版本的 preset 都已经被它取代)。<br>◆ @babel&#x2F;preset-env 包含 es 所有版本的 preset，会根据所配置的目标环境自动选择特定版本 preset 及相关 plugin，这里的自动选择机制的实现基于 browserslist、compat-table、electron-to-chromium 等开源项目维护的浏览器与 es 新特性及 plugin 的映射关系。<br>◆ 配置 Babel 目标环境的方式有如下两种：<br>（1）browserslist：在没有配置&quot;ignoreBrowserslistConfig&quot;且&quot;targets&quot;没有配置 browserslist 相关选项时被使用，示例如下，browserslist 会根据配置生成一个目标浏览器的列表，这个列表可以通过 npx browserslist &quot;<em>配置字符串</em>&quot; 命令查看。另外有<a target="_blank" rel="noopener" href="https://browsersl.ist/">网站</a>提供了目标浏览器列表的图形化展示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;browserslist&quot;: &quot;&gt; 0.25%, not dead&quot;  // 市场占有率大于0.25%的浏览器（不包括IE10和BlackBerry等停止升级的浏览器）</span><br></pre></td></tr></table></figure><p>（2）targets：&quot;targets&quot;配置支持更多的语法及其他可配置项：string | Array<string>| { [string]: string }，<a target="_blank" rel="noopener" href="https://babeljs.io/docs/options#targets">详细</a>，如：</string></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;targets&quot;: &quot;&gt; 0.25%, not dead&quot;  // 与上一条browserslist等价</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;targets&quot;: &#123;    // 指定特定具体目标环境</span><br><span class="line">    &quot;chrome&quot;: &quot;58&quot;,</span><br><span class="line">    &quot;ie&quot;: &quot;11&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>◆ browserslist 和 targets 的书写位置可选以下任一种：<br>（1）babel 配置文件中 全局 或 preset 或 plugin 的 option。<br>（2）package.json 文件中的字段。<br>（3）对于 browserslist，官方推荐写在.browserslistrc 文件，以适用于“ browserslist 同时提供给 babel 之外的库使用”的场景。</p><p>◆ 如果未配置目标运行平台，@babel&#x2F;preset-env 会转换所有 ECMAScript 2015+ 的代码，这样就失去了面向各平台定制的意义，不推荐。</p><h4 id="babel-preset-env-的常用配置项"><a href="#babel-preset-env-的常用配置项" class="headerlink" title="@babel&#x2F;preset-env 的常用配置项"></a>@babel&#x2F;preset-env 的常用配置项</h4><p>◆<a target="_blank" rel="noopener" href="https://babeljs.io/docs/babel-preset-env#modules">modules</a><br>（1）是否将 ES6 的 module 语法统一转换为指定的另一种 module 形式。<br>（2）取值：&quot;amd&quot; | &quot;umd&quot; | &quot;systemjs&quot; | &quot;commonjs&quot; | &quot;cjs&quot;（commonjs 的简写） | &quot;auto&quot; | false，默认值为&quot;auto&quot;，表示根据 caller 配置项判断，使用打包工具调用 Babel 情况下打包工具会自动提供 caller 配置项的值。<br>◆<a target="_blank" rel="noopener" href="https://babeljs.io/docs/options#targetsesmodules">targets.esmodules</a><br>（1）默认值是 false，即认为目标平台不支持 ES 模块的定义与导入导出方式。<br>（2）支持<script type="module"></script>标签的浏览器是支持 ES 模块的。<br>（3）设置 esmodules 之后其他 targets 设置将被忽略。<br>◆<a target="_blank" rel="noopener" href="https://babeljs.io/docs/babel-preset-env#usebuiltins">useBuiltIns</a><br>（1）标识如何处理全局垫片(polyfill，详见下一节)，取值：&quot;usage&quot; | &quot;entry&quot; | false。<br>（2）默认值为 false 不做处理，此时 Babel 只转换新语法，不会转换 polyfill 所包含的 Promise 和 Symbol 等新的内置类型、Array.from 和 Object.assign 等新的静态方法、Array.prototype.includes 等新的实例方法、generator 方法。<br>（3）取值&quot;usage&quot;或&quot;entry&quot;时都需要安装@babel&#x2F;polyfill(官方推荐按需安装 core-js 或 regenerator-runtime，详见下一节)配合使用，并设置与&quot;useBuiltIns&quot;并列的&quot;corejs&quot;配置项指明所使用的 core-js 版本。<br>（4）取值“entry”，需要在项目代码中手动引入 core-js 或 regenerator-runtime，且当仅 import 某个单独特性时支持模糊写法(如：import &quot;core-js&#x2F;es&#x2F;array&quot;)，@babel&#x2F;preset-env 会根据目标环境引入与特性关联的各具体文件（如在目标 safari 6 配置下会引入 core-js&#x2F;modules&#x2F;es.array.from、core-js&#x2F;modules&#x2F;es.array.for-each、core-js&#x2F;modules&#x2F;es.array.last-index-of、core-js&#x2F;modules&#x2F;es.array.copy-within 等文件的内容）;<br>（5）取值“usage”，无需在项目代码中手动引入任何 core-js 或 regenerator-runtime，@babel&#x2F;preset-env 会根据代码实际使用了哪些新特性并结合目标环境引入具体文件内容。<br>◆<a target="_blank" rel="noopener" href="https://babeljs.io/docs/babel-preset-env#corejs">corejs</a><br>取值 string 或{ version: string, proposals: boolean }，与&quot;useBuiltIns&quot;配合使用，见&quot;useBuiltIns&quot;（3）的说明。</p><h3 id="polyfill"><a href="#polyfill" class="headerlink" title="polyfill"></a>polyfill</h3><h4 id="babel-polyfill"><a href="#babel-polyfill" class="headerlink" title="@babel&#x2F;polyfill"></a>@babel&#x2F;polyfill</h4><p>■ @babel&#x2F;polyfill(曾用名 babel-polyfill)包含 core-js(polyfill ES features)和 regenerator-runtime(to use transpiled generator functions)两部分，用于模拟一个完整的 ES2015+目标环境。<br>■ 官方推荐按需分别安装 core-js 或 regenerator-runtime 替代 @babel&#x2F;polyfill（<strong>20230219 更新</strong>：@babel&#x2F;polyfill 这个包已被弃用），并且不要直接整体引入，而推荐通过上节描述的 @babel&#x2F;preset-env 的 UseBuiltins 选项选择性地引入所需特性，从而避免不必要的输出包体积增加。<br>■ @babel&#x2F;polyfill 垫片通过在全局作用域增加类和函数定义、以及为内置类型和内置对象增加静态方法和增加 prototype 属性等修改全局环境的方式实现的，在不希望产生副作用的场景下，特别是项目定位是 tool&#x2F;library 而不是 application 的时候，这种实现方式不适合。<br>■ polyfill 方式的配置：<br>（1）babel 配置文件中配置 @babel&#x2F;preset-env 的&quot;useBuiltIns&quot;和&quot;corejs&quot;项，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...&quot;presets&quot;: [</span><br><span class="line">  ...</span><br><span class="line">  [&quot;@babel/preset-env&quot;,&#123;</span><br><span class="line">    &quot;useBuiltIns&quot;: &quot;usage&quot;,</span><br><span class="line">    &quot;corejs&quot;: &quot;3.28&quot;,</span><br><span class="line">    ...</span><br><span class="line">  &#125;],</span><br><span class="line">  ...</span><br><span class="line">]...</span><br></pre></td></tr></table></figure><p>（2）如果使用 rollup，还需配置 @rollup&#x2F;plugin-babel 的&quot;babelHelpers&quot;值为“bundled”。</p><h4 id="babel-runtime"><a href="#babel-runtime" class="headerlink" title="@babel&#x2F;runtime"></a>@babel&#x2F;runtime</h4><p>○ @babel&#x2F;runtime(曾用名 babel-runtime)作用同@babel&#x2F;polyfill，区别是它通过注入模块化 helper(modular runtime helpers)的方式实现 core-js 和 regenerator-runtime 两部分垫片。<br>○ runtime 相关包目前有三个：<br>（1）@babel&#x2F;runtime（仅包含 regenerator-runtime ）。<br>（2）@babel&#x2F;runtime-corejs2（包含 regenerator-runtime 和 core-js）。<br>（3）@babel&#x2F;runtime-corejs3（包含 regenerator-runtime 和 core-js-pure），它<a target="_blank" rel="noopener" href="https://babeljs.io/docs/babel-plugin-transform-runtime#corejs">与@babel&#x2F;runtime-corejs2 的区别</a>是除了支持全局类型与类型新的静态方法垫片之外，也支持类型新的实例方法垫片。所以通常安装这个 runtime 包。<br>○ 除了安装 @babel&#x2F;runtime-corejs3 之外，也需要安装@babel&#x2F;plugin-transform-runtime 插件用于处理重复 helper 代码的复用。<br>○ runtime 方式的配置：<br>（1）@babel&#x2F;plugin-transform-runtime 插件没有像 polyfill 方式那样的“useBuiltIns: &#39;usage&#39;”选项，自身也没有“browserslist”或“targets”选项，会对代码中出现的所有垫片特性注入 helper（相关 issue：<a target="_blank" rel="noopener" href="https://github.com/babel/babel/issues/7330">7330</a>，<a target="_blank" rel="noopener" href="https://github.com/babel/babel/issues/10250">10250</a>）。<strong>20230221 更新</strong>：实践发现 babel 配置的全局 targets 项 ↓ 和全局“.browserslistrc”文件方式可使 @babel&#x2F;plugin-transform-runtime 插件按需注入 helper。<br>（2）babel 配置中增加 @babel&#x2F;plugin-transform-runtime 的如下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&quot;targets&quot;: &quot;&gt; 0.25%, not dead&quot;, // ↑ 使 @babel/plugin-transform-runtime 插件按需注入 helper</span><br><span class="line">&quot;plugins&quot;: [</span><br><span class="line">  ...</span><br><span class="line">  [&quot;@babel/plugin-transform-runtime&quot;,&#123;</span><br><span class="line">    &quot;corejs&quot;: 3,</span><br><span class="line">  &#125;],</span><br><span class="line">  ...</span><br><span class="line">]...</span><br></pre></td></tr></table></figure><p>（3）如果使用 rollup，还需配置@rollup&#x2F;plugin-babel 的&quot;babelHelpers&quot;值为“runtime”。</p><h4 id="从打包内容看-polyfill-方式与-runtime-方式区别"><a href="#从打包内容看-polyfill-方式与-runtime-方式区别" class="headerlink" title="从打包内容看 polyfill 方式与 runtime 方式区别"></a>从打包内容看 polyfill 方式与 runtime 方式区别</h4><p>◆ 以 webpack 打包目标环境不支持 Array.from 和 Array.prototype.includes 的以下原始内容为例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.from(&quot;how are you&quot;);</span><br><span class="line">[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;].includes(&quot;a&quot;);</span><br></pre></td></tr></table></figure><p>◆ 使用的 polyfill 方式的相应输出大致如下(已简化)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">/* 38 */  /*Array.from的实现与全局注册*/</span><br><span class="line">...</span><br><span class="line">/* 39 */  /*Array.prototype.includes的实现与全局注册*/</span><br><span class="line">...</span><br><span class="line">var core_js_modules_es_array_from__IMPORTED_MODULE = __webpack_require__(38);</span><br><span class="line">var core_js_modules_es_array_includes__IMPORTED_MODULE  = __webpack_require__(39);</span><br><span class="line"></span><br><span class="line">Array.from(&quot;how are you&quot;);</span><br><span class="line">[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;].includes(&quot;a&quot;);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>◆ 使用的 runtime 方式的相应输出大致如下(已简化)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">/* 38 */  /*Array.from的模块化实现*/</span><br><span class="line">...</span><br><span class="line">/* 39 */  /*Array.prototype.includes的模块化实现*/</span><br><span class="line">...</span><br><span class="line">var _babel_runtime_array_from__IMPORTED_MODULE = __webpack_require__(38);</span><br><span class="line">var _babel_runtime_instance_includes__IMPORTED_MODULE  = __webpack_require__(39);</span><br><span class="line"></span><br><span class="line">_babel_runtime_array_from__IMPORTED_MODULE()(&quot;how are you&quot;);</span><br><span class="line">_babel_runtime_instance_includes__IMPORTED_MODULE().call( [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], &quot;a&quot;));</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>◆ 最大区别在于 polyfill 方式由于修改了全局环境，原始代码写法被保留而不会被改写。<br>◆<strong>20230221 更新</strong>：polyfill 方式当前已支持通过<a target="_blank" rel="noopener" href="https://github.com/babel/babel/issues/10008">polyfill provider RFC</a>实现非全局垫片，<a target="_blank" rel="noopener" href="https://github.com/babel/babel/issues/6629#issuecomment-636192132">issue 说明</a>与<a target="_blank" rel="noopener" href="https://github.com/babel/babel-polyfills/tree/main/packages/babel-plugin-polyfill-corejs3">babel-plugin-polyfill-corejs3 的使用</a>。</p><h3 id="Babel-配置文件"><a href="#Babel-配置文件" class="headerlink" title="Babel 配置文件"></a>Babel 配置文件</h3><p>○ Babel 有两种配置文件，可以同时使用或单独使用。<br>（1）项目配置（Project-wide configuration），对整个项目生效，包含项目下的 node_modules（除非通过&quot;exclude&quot;排除），适合项目范围内广泛生效的配置，有&quot;babel.config.js 文件&quot;和&quot;babel.config.json 文件&quot;两种具体形式。<br>（2）文件关联配置（File-relative configuration），有&quot;.babelrc(同.babelrc.js)文件&quot;<br>和&quot;项目 package.json 文件中的 babel 字段&quot;两种具体形式。<br>○ 关于 Project-wide 配置：<br>（1）root 属性指明当前项目的根目录，Babel 默认以当前路径为 root 属性值，并在 root 路径下查找与应用&quot;babel.config.js&quot;文件配置。<br>○ 关于 File-relative 配置：<br>（1）适合为项目的子部分做配置。<br>（2）Babel 从被编译文件向上逐级查找与应用 File-relative 配置，未查找到则终止于 package.json 文件。<br>（3）查找 File-relative 配置的范围仅限通过 babelrcRoots 属性包含的路径，默认与 root 属性值一致，查找范围之外的文件关联配置 Babel 不会处理。<br>（4）Babel 7 新增特性： File-relative 配置的作用范围仅限 package 自己，不包含文件层级下面的 node_modules，也不会检测 node_modules 内的.babelrc，即使通过“include”包含了 node_modules。</p></div><blockquote class="post-copyright"><div class="content"></div><footer style="width:100%"><h5><span class="post-time">最后更新时间：<time datetime="2025-03-19T13:37:34.608Z" itemprop="dateUpdated">2025-03-19 21:37:34</time></span><span style="float:right"><img src="/img/avatar.jpg" alt="Congzhou">Congzhou</span></h5></footer></blockquote><div class="post-footer"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Babel/" rel="tag">Babel</a></li></ul></div></div><nav class="post-nav flex-row flex-justify-between"><div class="prev"><a href="/handbook/%E9%92%89%E9%92%89%E5%BE%AE%E5%BA%94%E7%94%A8%E4%B8%8E%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%85%8D%E7%99%BB%E6%B5%81%E7%A8%8B.html" id="post-prev" class="post-nav-link"><div class="tips"><i class="iconfont icon-arrow1l"></i>Prev</div><h4 class="title">钉钉微应用与小程序的免登流程</h4></a></div><div class="next"><a href="/knowledge/Java-web-%E6%8A%80%E6%9C%AF%E4%B8%8E%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E5%8E%86%E5%8F%B2.html" id="post-next" class="post-nav-link"><div class="tips">Next<i class="iconfont icon-arrow1r"></i></div><h4 class="title">Java web 技术与架构演进历史</h4></a></div></nav><div class="comments vcomment" id="comments"></div><script src="/js/valine.min.js"></script><script>var GUEST_INFO=["nick","mail","link"],guest_info="nick,mail,link".split(",").filter(function(e){return-1<GUEST_INFO.indexOf(e)}),required_info="nick,mail".split(",").filter(function(e){return-1<GUEST_INFO.indexOf(e)});new Valine({el:"#comments",appId:"tq4lHkryFNXHsw9SOypjPRwx-gzGzoHsz",appKey:"lFmuObNsezjTPj5e86R1TgOg",avatar:"mp",placeholder:"欢迎留言(支持Markdown语法), 将展示您邮箱绑定的Gravatar头像(如果有的话~)",meta:0==guest_info.length?GUEST_INFO:guest_info,pageSize:"10",recordIP:!1,requiredFields:required_info})</script></article></div><footer class="footer"><div class="bottom"><p><span>Copyright &copy; 2009-2025 Congzhou</span><span id="container_site_uv" style="display:none">总访客数：<span id="value_site_uv"></span></span><span id="container_site_pv" style="display:none">总访问量：<span id="value_site_pv"></span></span></p></div></footer></main><div class="mask" id="mask"></div><a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light" style="text-decoration:none"><span class="iconfont icon-arrow-up" style="font-size:25px;font-weight:700"></span></a><script>var BLOG={ROOT:"/",SHARE:!1,REWARD:!1}</script><script src="/js/main.min.js"></script><div class="search-panel" id="search-panel"><ul class="search-result" id="search-result"></ul></div><template id="search-tpl"><li class="item"><a href="{path}" class="waves-block waves-effect"><div class="title ellipsis" title="{title}">{title}</div><div class="flex-row flex-middle"><div class="tags ellipsis">{tags}</div><time class="flex-col time">{date}</time></div></a></li></template><script src="/js/search.min.js"></script><script>Observer.callback=function(){var e=document.querySelector("#value_page_pv");e.innerText=VISIT_INFO.curPagePV,e.parentNode.style.display="inline-block"},VISIT_INFO.curPagePV,Observer.callback=null,Observer.callback=function(){var e=document.querySelector("#value_site_pv");e.innerText=VISIT_INFO.totalPV,e.parentNode.style.display="inline-block"},VISIT_INFO.totalPV,Observer.callback=null,Observer.callback=function(){var e=document.querySelector("#value_site_uv");e.innerText=VISIT_INFO.totalUV,e.parentNode.style.display="inline-block"},VISIT_INFO.totalUV,Observer.callback=null,setTimeout(function(){var a=AV.Object.extend("visit_pv"),e=AV.Object.extend("visit_uv"),t=new AV.Query(a),o=location.pathname;location.hostname.match("localhost")?(t.equalTo("url",o),t.find().then(function(e){if(e.length){var t=e[0];VISIT_INFO.curPagePV=t.get("times")}else VISIT_INFO.curPagePV=0})):(t.equalTo("url",o),t.find().then(function(e){if(e.length){var t=e[0];VISIT_INFO.curPagePV=t.get("times"),t.increment("times",1),t.save()}else{VISIT_INFO.curPagePV=0;var l=new a;l.set("url",o),l.set("times",1);var n=document.querySelector(".post-card-title").innerText;l.set("title",n),l.save()}}));var l=localStorage.getItem("blog_UID");l||(l=generateUID(),localStorage.setItem("blog_UID",l)),AV.Cloud.run("total_pv").then(function(e){VISIT_INFO.totalPV=e}),location.hostname.match("localhost")||AV.Cloud.run("rec_uv",{UID:l}).then(function(e){}),new AV.Query(e).count().then(function(e){VISIT_INFO.totalUV=e+1998})},100)</script><script>"serviceWorker"in navigator&&(window.addEventListener("load",function(){navigator.serviceWorker.register("/service-worker.js").then(function(e){console.log("service-worker register ok")}).catch(function(e){console.log("service-worker register failed: "+e)})}),navigator.serviceWorker.addEventListener("controllerchange",function(){console.log("检测到缓存资源更新，刷新以获取新内容")}))</script></body></html>