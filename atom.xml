<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Congzhou&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/980cf029020f4fa51148ca21ab3e935c</icon>
  <subtitle>One today is worth two tomorrows!</subtitle>
  <link href="https://congzhou09.github.io/atom.xml" rel="self"/>
  
  <link href="https://congzhou09.github.io/"/>
  <updated>2025-04-29T12:26:55.860Z</updated>
  <id>https://congzhou09.github.io/</id>
  
  <author>
    <name>Congzhou</name>
    <email>congzhou09@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AFFiNE后端开发环境搭建</title>
    <link href="https://congzhou09.github.io/practice/AFFiNE%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html"/>
    <id>https://congzhou09.github.io/practice/AFFiNE%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</id>
    <published>2025-04-28T04:25:49.000Z</published>
    <updated>2025-04-29T12:26:55.860Z</updated>
    
    <content type="html"><![CDATA[<h3 id="环境参数"><a href="#环境参数" class="headerlink" title="环境参数"></a>环境参数</h3><p>◇ 我是在 Windows 上搭建的，以下版本号信息供参考，非必须完全一致。</p><table><thead><tr><th>Name</th><th align="left">version</th></tr></thead><tbody><tr><td>Win11</td><td align="left">24H2</td></tr><tr><td>Docker Desktop</td><td align="left">v4.40.0</td></tr><tr><td>rustc</td><td align="left">1.86.0</td></tr><tr><td>node</td><td align="left">v20.19.0</td></tr><tr><td>PostgreSQL</td><td align="left">17.4</td></tr><tr><td>Redis</td><td align="left">7.4.3</td></tr><tr><td>AFFiNE</td><td align="left">canary: 7e4af90c0311e498f5119b034397b5ae8a7af9ec</td></tr></tbody></table><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>◆ 在 AFFiNE 项目根目录执行 yarn install 成功安装所有依赖。<br>◆ 后端项目是其中的 @affine&#x2F;server 子项目。<br>◆ 安装 Docker Desktop 与 Rust。<br>◆ 使用 docker 运行 Redis，docker-compose.yaml 内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">services:</span><br><span class="line">  affine-redis:</span><br><span class="line">    image: redis:latest</span><br><span class="line">    container_name: affine-redis</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;6379:6379&quot;</span><br></pre></td></tr></table></figure><p>◆ 使用 docker 运行 PostgreSQL，docker-compose.yaml 内容如下。<br>（1）由于 Postgres 要求挂载目录支持硬链接（hard link），Windows 上不能使用本地磁盘目录。于是使用让 docker 创建的名为&quot;affine_pgdata&quot;的 volume 做数据持久化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">services:</span><br><span class="line">  affine-postgres:</span><br><span class="line">    image: postgres:latest</span><br><span class="line">    container_name: affine-postgres</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;5432:5432&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - affine_pgdata:/var/lib/postgresql/data</span><br><span class="line">volumes:</span><br><span class="line">  affine_pgdata:</span><br></pre></td></tr></table></figure><p>◆ 在数据库中创建项目所使用的用户名、密码与数据库实例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 进入数据库容器的数据库命令行</span><br><span class="line">docker exec -it affine-postgres psql -U postgres</span><br><span class="line"></span><br><span class="line"># 创建项目用户</span><br><span class="line">CREATE USER affine WITH PASSWORD &#x27;affine&#x27;;</span><br><span class="line">ALTER USER affine WITH SUPERUSER;</span><br><span class="line"></span><br><span class="line"># 创建数据库</span><br><span class="line">CREATE DATABASE affine;</span><br></pre></td></tr></table></figure><p>◆ 我使用开发环境下会自动创建的用户调试(packages\backend\server\src\core\auth\dev.ts\createDevUsers())，所以未启动 mailhog 服务也未在下一步配置 mail 相关字段。</p><p>◆ 项目数据库连接配置，进入项目 packages\backend\server 路径，参考&quot;.env.example&quot;创建配置文件&quot;.env&quot;，文件内容如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DATABASE_URL=&quot;postgres://affine:affine@localhost:5432/affine&quot;</span><br></pre></td></tr></table></figure><p>◆ 使用项目所依赖的 prisma 创建项目数据库表，在项目根目录执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn workspace @affine/server prisma db push</span><br></pre></td></tr></table></figure><p>◆ 如果上步执行报错：Could not open extension control file &quot;&#x2F;usr&#x2F;share&#x2F;postgresql&#x2F;17&#x2F;extension&#x2F;vector.control&quot;: No such file or directory。则执行以下步骤后重新执行上步命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 进入数据库容器的bash命令行</span><br><span class="line">docker exec -it affine-postgres /bin/bash</span><br><span class="line"></span><br><span class="line"># 更新apt-get工具</span><br><span class="line">apt-get update</span><br><span class="line"></span><br><span class="line"># 安装缺少的vector扩展，其中的&quot;17&quot;与报错信息里的一致</span><br><span class="line">apt-get install postgresql-17-pgvector</span><br></pre></td></tr></table></figure><p>◆ 初始化数据库中的项目数据。在项目根目录执行下面命令，注意要带上&quot;run&quot;，不然所执行的&quot;yarn init&quot;就是 yarn 自带的 init 命令了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn workspace @affine/server run init</span><br></pre></td></tr></table></figure><p>◆ 编译 @affine&#x2F;server 所依赖的 @affine&#x2F;server-native。执行下面命令，此时会用到 Rust 环境。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn workspace @affine/server-native build:debug</span><br></pre></td></tr></table></figure><p>◆ 如果上步执行报错：&#39;cargo&#39; 不是内部或外部命令，也不是可运行的程序。则执行以下步骤后重新执行上步命令。<br>（1）确认 Rust 已安装，powershell 和 cmd 中 cargo --version 打印正常。<br>（2）终端正常启动时会加载用户级+系统级的 PATH 变量，确认环境变量的 PATH 中存在&quot;C:\Users\用户名\.cargo\bin&quot;。<br>（3）在报错位置&quot;node_modules\@napi-rs\cli\dist\utils\metadata.js&quot;，增加 console.log(process.env.PATH)打印，看其中是否没有&quot;C:\Users\用户名\.cargo\bin&quot;。原因很可能是在安装完 Rust 后的广播 PATH 变更环节异常，重启电脑可解决。</p><p>◆ 启动后端。在项目根目录执行 yarn dev，选择&quot;@affine&#x2F;server&quot;。</p><h3 id="admin-管理页面"><a href="#admin-管理页面" class="headerlink" title="admin 管理页面"></a>admin 管理页面</h3><p>△ 以 self-hosted 模式部署的 AFFiNE 可以通过 http://locahost:3010/admin 访问 admin 管理页面。本地开发环境需要做下面两步操作才可以。</p><h4 id="self-hosted-模式"><a href="#self-hosted-模式" class="headerlink" title="self-hosted 模式"></a>self-hosted 模式</h4><p>□ 在.env 文件中追加 DEPLOYMENT_TYPE 字段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEPLOYMENT_TYPE=&quot;selfhosted&quot;</span><br></pre></td></tr></table></figure><h4 id="admin-页面资源"><a href="#admin-页面资源" class="headerlink" title="admin 页面资源"></a>admin 页面资源</h4><p>○ 编译 @affine&#x2F;admin。项目根目录执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn affine @affine/admin build</span><br></pre></td></tr></table></figure><p>○ 拷贝 packages\frontend\admin\dist 下的所有内容到 packages\backend\server\static\admin</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>●<a href="https://docs.affine.pro/docs/development/dev-guide/node-dev-guide">官方 Doc 网站-Node Dev Guide</a><br>●<a href="https://alien.slackbook.org/blog/slackware-cloud-server-series-episode-10-workflow-management/">self-hosted 模式 AFFiNE 的部署</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;环境参数&quot;&gt;&lt;a href=&quot;#环境参数&quot; class=&quot;headerlink&quot; title=&quot;环境参数&quot;&gt;&lt;/a&gt;环境参数&lt;/h3&gt;&lt;p&gt;◇ 我是在 Windows 上搭建的，以下版本号信息供参考，非必须完全一致。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr</summary>
      
    
    
    
    <category term="实践总结" scheme="https://congzhou09.github.io/categories/practice/"/>
    
    
    <category term="AFFiNE" scheme="https://congzhou09.github.io/tags/AFFiNE/"/>
    
  </entry>
  
  <entry>
    <title>基于verdaccio的npm私有仓库</title>
    <link href="https://congzhou09.github.io/practice/%E5%9F%BA%E4%BA%8Everdaccio%E7%9A%84npm%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93.html"/>
    <id>https://congzhou09.github.io/practice/%E5%9F%BA%E4%BA%8Everdaccio%E7%9A%84npm%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93.html</id>
    <published>2024-11-25T13:03:36.000Z</published>
    <updated>2025-03-22T14:44:52.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>● <a href="https://verdaccio.org/">Verdaccio</a> 是个轻量的基于 Node.js 的 npm 私有仓库。<br>● 支持 npm 主流客户端(yarn&#x2F;npm&#x2F;pnpm)，支持代理到其他 registry 地址及缓存加速。</p><h2 id="docker-compose-方式运行-linux"><a href="#docker-compose-方式运行-linux" class="headerlink" title="docker-compose 方式运行(linux)"></a>docker-compose 方式运行(linux)</h2><p>◇ 参考<a href="https://verdaccio.org/docs/docker">官方文档对 docker 方式的说明</a>。<br>◇ 指定一个存放路径。此处以此路径为例：&#x2F;app&#x2F;deploy&#x2F;verdaccio。<br>◇ 在路径下创建三个子文件夹：config、plugins、storage。<br>◇ 由于 Verdaccio 在容器内使用的是 UID&#x3D;10001 且 GID&#x3D;65533 的非 root 用户，递归设置挂载目录的用户和用户组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R 10001:65533 /app/deploy/verdaccio</span><br></pre></td></tr></table></figure><p>◇ 参考官方<a href="https://github.com/verdaccio/verdaccio/blob/master/packages/config/src/conf/default.yaml">示例配置文件</a>在 config 文件夹下准备 config.yaml，示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"># path to a directory with all packages</span><br><span class="line">storage: /verdaccio/storage</span><br><span class="line"># path to a directory with plugins to include, the plugins folder has the higher priority for loading plugins</span><br><span class="line"># disable this folder to avoid warnings if is not used</span><br><span class="line"># plugins: ./plugins</span><br><span class="line"></span><br><span class="line">web:</span><br><span class="line">  enable: true</span><br><span class="line">  title: npm | example</span><br><span class="line">  logo: https://static-production.npmjs.com/b0f1a8318363185cc2ea6a40ac23eeb2.png</span><br><span class="line">  favicon: https://static-production.npmjs.com/b0f1a8318363185cc2ea6a40ac23eeb2.png</span><br><span class="line">  primary_color: &#x27;#3990f6&#x27;</span><br><span class="line">  showInfo: false</span><br><span class="line">  showSettings: false</span><br><span class="line">  showFooter: false</span><br><span class="line">  showUplinks: false</span><br><span class="line">  showDownloadTarball: false</span><br><span class="line">  showRaw: false</span><br><span class="line"></span><br><span class="line">url_prefix: &#x27;/&#x27;</span><br><span class="line">max_body_size: 300mb # max package&#x27;s size 300M</span><br><span class="line"></span><br><span class="line">auth:</span><br><span class="line">  htpasswd:</span><br><span class="line">    file: /verdaccio/storage/htpasswd # where to store login info</span><br><span class="line">    # Maximum amount of users allowed to register, defaults to &quot;+inf&quot;.</span><br><span class="line">    # Set to -1 to disable registration.</span><br><span class="line">    max_users: -1</span><br><span class="line"></span><br><span class="line">uplinks:</span><br><span class="line">  npmjs:</span><br><span class="line">    url: https://registry.npmjs.org/</span><br><span class="line">packages:</span><br><span class="line"></span><br><span class="line">  &#x27;**&#x27;:</span><br><span class="line">    # you can specify usernames/groupnames (depending on your auth plugin)</span><br><span class="line">    # and three keywords: &quot;$all&quot;, &quot;$anonymous&quot;, &quot;$authenticated&quot;</span><br><span class="line">    access: $authenticated</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    publish: $authenticated</span><br><span class="line">    # if package is not available locally, proxy requests to &#x27;npmjs&#x27; registry</span><br><span class="line">    proxy: npmjs</span><br><span class="line">security:</span><br><span class="line">  web:</span><br><span class="line">    sign:</span><br><span class="line">      expiresIn: 30d # login expiration time, examples: 1h, 7d</span><br><span class="line"></span><br><span class="line">log:</span><br><span class="line">  - &#123; type: stdout, format: pretty, level: trace &#125;</span><br><span class="line">  #- &#123;type: file, path: verdaccio.log, level: info&#125;</span><br></pre></td></tr></table></figure><p>◇ 创建 docker-compose.yml 文件，内容示例如下。<strong>其中 VERDACCIO_PUBLIC_URL 不能为空，且需设置成域名网址而不能是相对路径</strong>(以 https://npm.my.cn 为例)，否则 Verdaccio 将使用默认的 http://localhost:4873/ 作为所生成所有资源链接(如包的访问链接)的基础 URL。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">name: verdaccio</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  verdaccio:</span><br><span class="line">    image: verdaccio/verdaccio:6.0.2</span><br><span class="line">    container_name: &#x27;verdaccio&#x27;</span><br><span class="line">    environment:</span><br><span class="line">      - VERDACCIO_PUBLIC_URL=https://npm.my.cn</span><br><span class="line">      - VERDACCIO_PORT=4873</span><br><span class="line">    ports:</span><br><span class="line">      - &#x27;4873:4873&#x27;</span><br><span class="line">    volumes:</span><br><span class="line">      - &#x27;./storage:/verdaccio/storage&#x27;</span><br><span class="line">      - &#x27;./config:/verdaccio/conf&#x27;</span><br><span class="line">      - &#x27;./plugins:/verdaccio/plugins&#x27;</span><br></pre></td></tr></table></figure><p>◇ 在 docker-compose.yml 文件同级目录下执行&quot;docker compose up -d&quot;命令启动。</p><h2 id="私有仓库的使用"><a href="#私有仓库的使用" class="headerlink" title="私有仓库的使用"></a>私有仓库的使用</h2><p>■ 以下私有仓库地址以 https://npm.my.cn 为例。</p><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p>■ 创建用户。在上述 config.yaml 配置中 max_users 不等于 -1 的情况下，执行：npm adduser --registry https://npm.my.cn。仓库连接成功会自动提示输入用户名密码等信息。<br>■ 手动登录。执行：npm login --registry https://npm.my.cn。<br>■ 自动登录。将登录信息保存到项目根目录的.npmrc 中可避免手动 login 的过程。示例如下。其中的&lt;passwordToBase64&gt;可通过执行&quot;echo -n &lt;password&gt; | base64&quot;得到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//npm.my.cn/:username=&lt;username&gt;</span><br><span class="line">//npm.my.cn/:_password=&lt;passwordToBase64&gt;</span><br></pre></td></tr></table></figure><h3 id="包的发布"><a href="#包的发布" class="headerlink" title="包的发布"></a>包的发布</h3><p>■ 将包发布到私有仓库，在 publish 命令上增加参数：--registry https://npm.my.cn<br>■ registry 除了命令行参数方式之外，也支持添加到.npmrc 文件，以及 package.json 文件的 publishConfig 字段。三者优先级依次递减。示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//.npmrc 文件</span><br><span class="line">registry=https://npm.my.cn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// package.json文件</span><br><span class="line">&#123;</span><br><span class="line">  ... ...</span><br><span class="line">  &quot;publishConfig&quot;: &#123;</span><br><span class="line">    &quot;registry&quot;: &quot;https://npm.my.cn&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>■ 包大小限制的调整：<br>（1）nginx 默认消息体大小限制 1M，通过 nginx 指令“client_max_body_size 300M”调整。<br>（2）verdiccio 默认包大小限制 10M，通过 config.yaml 中的“max_body_size: 300mb”调整。</p><h3 id="包的安装"><a href="#包的安装" class="headerlink" title="包的安装"></a>包的安装</h3><p>■ 所有包都从私有仓库下载。通过上述 --registry 命令行参数或 .npmrc 中的 registry 字段可实现。<br>■ 仅私有包从私有仓库下载。.npmrc 提供了为特定域或包名指定仓库地址的配置语法，但实践发现 pnpm 和 yarn 对这类语法的支持不完善或不统一，可通过将 package.json 的 dependencies 中包的版本号指定为带基础 URL 的完整下载地址实现，如：&quot;demo-pkg&quot;: &quot;https://npm.my.cn/demo-pkg/-/demo-pkg-0.0.11.tgz&quot;。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;● &lt;a href=&quot;https://verdaccio.org/&quot;&gt;Verdaccio&lt;/a&gt; 是个轻量的基于 Node.js 的 npm</summary>
      
    
    
    
    <category term="实践总结" scheme="https://congzhou09.github.io/categories/practice/"/>
    
    
    <category term="Node.js" scheme="https://congzhou09.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>基于阿里云ACK Serverless搭建按量付费的gitlab-runner</title>
    <link href="https://congzhou09.github.io/practice/%E5%9F%BA%E4%BA%8E%E9%98%BF%E9%87%8C%E4%BA%91ACK-Serverless%E6%90%AD%E5%BB%BA%E6%8C%89%E9%87%8F%E4%BB%98%E8%B4%B9%E7%9A%84gitlab-runner.html"/>
    <id>https://congzhou09.github.io/practice/%E5%9F%BA%E4%BA%8E%E9%98%BF%E9%87%8C%E4%BA%91ACK-Serverless%E6%90%AD%E5%BB%BA%E6%8C%89%E9%87%8F%E4%BB%98%E8%B4%B9%E7%9A%84gitlab-runner.html</id>
    <published>2024-07-28T13:42:01.000Z</published>
    <updated>2025-03-19T13:37:34.701Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方案说明"><a href="#方案说明" class="headerlink" title="方案说明"></a>方案说明</h2><p>◆ 由于 CI&#x2F;CD 的非持续运行而运行期间又需要较高系统资源的特性，符合 ACK Serverless 按资源使用时间计费的场景，降低 CI&#x2F;CD 成本的同时又能提高并行多任务的执行效率。<br>◆ 方案的系统结构与流程如下面来自参考文档[1]的截图，当没有任务时仅 gitlab-runner 作为一个 pod 始终运行，以随时接受来自 gitlab 的任务分配。当有任务需要执行时，针对每个任务创建一个 kubernetes executor 类型的 pod 执行任务，且任务执行结束后，这些 kubernetes executor 类型的 pod 会自动销毁。</p><div class="img-container" style="width: 87%;"><img  src="/practice/%E5%9F%BA%E4%BA%8E%E9%98%BF%E9%87%8C%E4%BA%91ACK-Serverless%E6%90%AD%E5%BB%BA%E6%8C%89%E9%87%8F%E4%BB%98%E8%B4%B9%E7%9A%84gitlab-runner/structure_and_process.png" class="" onerror="imgOnError(this);" data-fancybox ></div><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="准备-ACK-Serverless-集群环境"><a href="#准备-ACK-Serverless-集群环境" class="headerlink" title="准备 ACK Serverless 集群环境"></a>准备 ACK Serverless 集群环境</h3><p>● 在阿里云工作台页面创建 ACK Serverless 类型的 kubernetes 集群。<br>● 根据&quot;集群信息&quot;中的&quot;连接信息&quot;，配置本地 kubectl，使可以在本地 kubectl 上对集群做操作。</p><h3 id="准备配置文件"><a href="#准备配置文件" class="headerlink" title="准备配置文件"></a>准备配置文件</h3><p>◇ 从 GitHub 上 clone 由参考文档[1]提供的<a href="https://github.com/aliyuneci/BestPractice-Serverless-Kubernetes">配置文件样例</a>到本地，使用其中&quot;eci-gitlab-runner&quot;文件夹里的配置文件。<br>◇ 以下配置的内容最终将集中到 config-map.yml 并经由集群的 deployment 被 mount 到 config.toml 文件，以方便地应用到所部署的 gitlab-runner pod 中。<br>◇ 未来由 gitlab-runner 拉起的 kubernetes executor 类型 pod 的配置也在这个 config.toml 文件里的，部分配置也会被 mount 成 pod 中的文件。<br>◇ 以下配置内容和命令中的所有由&quot;${}&quot;包裹的变量都需要替换成实际值。</p><h4 id="secret"><a href="#secret" class="headerlink" title="secret"></a>secret</h4><p>◆ 通过 secret 存放 kubernetes 集群、docker registry、git ssh 的鉴权信息。<br>◆ 修改样例 secret.yaml 配置，其中的 ca.crt、tls.crt、tls.key 依次填写集群连接信息里的 certificate-authority-data、client-certificate-data、client-key-data。<br>◆ 执行&quot;kubectl apply -f secret.yaml&quot;使生效。secret.yaml 完整内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  name: gitlab-runner-secret</span><br><span class="line">type: kubernetes.io/tls</span><br><span class="line">data:</span><br><span class="line">  ca.crt: $&#123;ca.crt&#125;</span><br><span class="line">  tls.crt: $&#123;tls.crt&#125;</span><br><span class="line">  tls.key: $&#123;tls.key&#125;</span><br></pre></td></tr></table></figure><p>◆ 如果 gitlab 的 pipeline 任务需要推送 docker 镜像到镜像仓库，则在集群创建名为&quot;registry-auth-secret&quot;的 secret，执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create secret docker-registry registry-auth-secret --docker-server=$&#123;registry-server-hostname&#125; --docker-username=$&#123;username&#125; --docker-password=$&#123;password&#125;</span><br></pre></td></tr></table></figure><p>◆ 如果 gitlab 的 pipeline 任务需要 clone 其他 git 仓库，则在集群创建名为&quot;gitlab-credentials&quot;的 secret，执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create secret generic gitlab-credentials --from-file=id_rsa=$&#123;pathto_id_rsa&#125; --from-file=id_rsa.pub=$&#123;pathto_id_rsa.pub&#125; --from-file=known_hosts=$&#123;pathto_known_hosts&#125;</span><br></pre></td></tr></table></figure><p>◆ secret 创建成功后可在&quot;阿里云工作台页面集群详情-&gt;配置管理-&gt;保密字典&quot;位置看到。</p><div class="img-container" style="width: 50%;"><img  src="/practice/%E5%9F%BA%E4%BA%8E%E9%98%BF%E9%87%8C%E4%BA%91ACK-Serverless%E6%90%AD%E5%BB%BA%E6%8C%89%E9%87%8F%E4%BB%98%E8%B4%B9%E7%9A%84gitlab-runner/secret_in_workbench.png" class="" onerror="imgOnError(this);" data-fancybox ></div><h4 id="配置-cache"><a href="#配置-cache" class="headerlink" title="配置 cache"></a>配置 cache</h4><p>● gitlab 的 cache 用于让 executor 缓存文件与文件夹以减少重复的下载、安装等工作。<br>● executor 容器的 cache 存储到的默认路径是&quot;&#x2F;cache&quot;，样例已经在 config-map.yaml 中将 pvc 配置到了此路径。</p><div class="img-container" style="width: 50%;"><img  src="/practice/%E5%9F%BA%E4%BA%8E%E9%98%BF%E9%87%8C%E4%BA%91ACK-Serverless%E6%90%AD%E5%BB%BA%E6%8C%89%E9%87%8F%E4%BB%98%E8%B4%B9%E7%9A%84gitlab-runner/cache_path_in_configmap.png" class="" onerror="imgOnError(this);" data-fancybox ></div><p>● 准备好 NAS(Network Attached Storage) 盘，将其地址与缓存文件夹根目录(此处定义为&#x2F;gitlab-runner-cache)填写到 nas-pv.yaml。nas-pv.yaml 完整内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: gitlab-runner-cache-pv</span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">  - ReadWriteOnce</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 10Gi</span><br><span class="line">  mountOptions:</span><br><span class="line">  - nolock,noresvport,noacl,hard</span><br><span class="line">  - vers=3</span><br><span class="line">  - rsize=1048576</span><br><span class="line">  - wsize=1048576</span><br><span class="line">  - proto=tcp</span><br><span class="line">  - timeo=600</span><br><span class="line">  - retrans=2</span><br><span class="line">  nfs:</span><br><span class="line">    path: /gitlab-runner-cache</span><br><span class="line">    server: $&#123;nas-server&#125;</span><br></pre></td></tr></table></figure><p>● 相应的 nas-pvc.yaml 直接使用样例的即可。nas-pvc.yaml 完整内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: gitlab-runner-cache-pvc</span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">  - ReadWriteOnce</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 10Gi</span><br><span class="line">  volumeName: gitlab-runner-cache-pv</span><br></pre></td></tr></table></figure><p>● 分别执行&quot;kubectl apply -f nas-pv.yaml&quot;和&quot;kubectl apply -f nas-pvc.yaml&quot;使生效。<br>◆ pv 与 pvc 创建成功后可分别在&quot;阿里云工作台页面集群详情-&gt;存储-&gt;存储卷|存储声明&quot;位置看到。</p><div class="img-container" style="width: 80%;"><img  src="/practice/%E5%9F%BA%E4%BA%8E%E9%98%BF%E9%87%8C%E4%BA%91ACK-Serverless%E6%90%AD%E5%BB%BA%E6%8C%89%E9%87%8F%E4%BB%98%E8%B4%B9%E7%9A%84gitlab-runner/pv_and_pvc_in_workbench.png" class="" onerror="imgOnError(this);" data-fancybox ></div><h4 id="配置-image-cache"><a href="#配置-image-cache" class="headerlink" title="配置 image-cache"></a>配置 image-cache</h4><p>○ imagecache-crd(Custom Resource Definition，CRD)是用于实现镜像缓存的 kubernetes 控制器，样例在 config-map.yaml 和 gitlab-runner-deployment.yaml 中通过 k8s.aliyun.com&#x2F;eci-image-cache 这个自定义注解标识了对 imagecache 的启用。</p><div class="img-container" style="width: 65%;"><img  src="/practice/%E5%9F%BA%E4%BA%8E%E9%98%BF%E9%87%8C%E4%BA%91ACK-Serverless%E6%90%AD%E5%BB%BA%E6%8C%89%E9%87%8F%E4%BB%98%E8%B4%B9%E7%9A%84gitlab-runner/imagecache_in_configmap.png" class="" onerror="imgOnError(this);" data-fancybox ></div><div class="img-container" style="width: 50%;"><img  src="/practice/%E5%9F%BA%E4%BA%8E%E9%98%BF%E9%87%8C%E4%BA%91ACK-Serverless%E6%90%AD%E5%BB%BA%E6%8C%89%E9%87%8F%E4%BB%98%E8%B4%B9%E7%9A%84gitlab-runner/imagecache_in_deployment.png" class="" onerror="imgOnError(this);" data-fancybox ></div><p>○ 通过&quot;kubectl get crd&quot;命令查看 imagecache-crd 是否已安装。如果未安装则通过&quot;kubectl apply -f imagecache-crd.yaml&quot;安装。直接使用样例的 imagecache-crd.yaml 即可，完整内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apiextensions.k8s.io/v1beta1</span><br><span class="line">kind: CustomResourceDefinition</span><br><span class="line">metadata:</span><br><span class="line">  name: imagecaches.eci.alibabacloud.com</span><br><span class="line">spec:</span><br><span class="line">  group: eci.alibabacloud.com</span><br><span class="line">  version: v1</span><br><span class="line">  names:</span><br><span class="line">    kind: ImageCache</span><br><span class="line">    plural: imagecaches</span><br><span class="line">    shortNames:</span><br><span class="line">    - ic</span><br><span class="line">    categories:</span><br><span class="line">    - all</span><br><span class="line">  scope: Cluster</span><br><span class="line">  subresources:</span><br><span class="line">    status: &#123;&#125;</span><br><span class="line">  validation:</span><br><span class="line">    openAPIV3Schema:</span><br><span class="line">      required:</span><br><span class="line">      - spec</span><br><span class="line">      properties:</span><br><span class="line">        spec:</span><br><span class="line">          type: object</span><br><span class="line">          required:</span><br><span class="line">          - images</span><br><span class="line">          properties:</span><br><span class="line">            imagePullSecrets:</span><br><span class="line">              type: array</span><br><span class="line">              items:</span><br><span class="line">                type: string</span><br><span class="line">            images:</span><br><span class="line">              minItems: 1</span><br><span class="line">              type: array</span><br><span class="line">              items:</span><br><span class="line">                type: string</span><br><span class="line">            imageCacheSize:</span><br><span class="line">              type: integer</span><br><span class="line">  additionalPrinterColumns:</span><br><span class="line">  - name: Age</span><br><span class="line">    type: date</span><br><span class="line">    JSONPath: .metadata.creationTimestamp</span><br><span class="line">  - name: CacheId</span><br><span class="line">    type: string</span><br><span class="line">    JSONPath: .status.imageCacheId</span><br><span class="line">  - name: Phase</span><br><span class="line">    type: string</span><br><span class="line">    JSONPath: .status.phase</span><br><span class="line">  - name: Progress</span><br><span class="line">    type: string</span><br><span class="line">    JSONPath: .status.progress</span><br></pre></td></tr></table></figure><p>○ 根据实际需要将待缓存的 docker 镜像名填写到 imagecache.yaml 中，我使用的 imagecache.yaml 完整内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: eci.alibabacloud.com/v1</span><br><span class="line">kind: ImageCache</span><br><span class="line">metadata:</span><br><span class="line">  name: gitlab-runner</span><br><span class="line">spec:</span><br><span class="line">  images:</span><br><span class="line">  - gitlab/gitlab-runner-helper:x86_64-latest</span><br><span class="line">  - gitlab/gitlab-runner:latest</span><br><span class="line">  - node:20-alpine</span><br><span class="line">  - node:20</span><br><span class="line">  - mcr.microsoft.com/playwright:v1.44.0-jammy</span><br><span class="line">  - gcr.io/kaniko-project/executor:v1.14.0-debug</span><br></pre></td></tr></table></figure><p>○ 执行&quot;kubectl apply -f imagecache.yaml&quot;使生效。<br>○ imagecache 创建成功后可在&quot;阿里云工作台页面集群详情-&gt;工作负载-&gt;自定义资源-&gt;资源对象浏览器&quot;位置看到。</p><div class="img-container" style="width: 80%;"><img  src="/practice/%E5%9F%BA%E4%BA%8E%E9%98%BF%E9%87%8C%E4%BA%91ACK-Serverless%E6%90%AD%E5%BB%BA%E6%8C%89%E9%87%8F%E4%BB%98%E8%B4%B9%E7%9A%84gitlab-runner/imagecache_in_workbench.png" class="" onerror="imgOnError(this);" data-fancybox ></div><h4 id="配置-ConfigMap"><a href="#配置-ConfigMap" class="headerlink" title="配置 ConfigMap"></a>配置 ConfigMap</h4><p>◇ gitlab-runner 的配置文件在容器虚拟机的默认位置是&quot;&#x2F;etc&#x2F;gitlab-runner&#x2F;config.toml&quot;，样例已经在 gitlab-runner-deployment.yaml 中将 configMap 的 mountPath 配置到了&#x2F;etc&#x2F;gitlab-runner。<br>◇ 参照<a href="https://docs.gitlab.com/ee/ci/runners/runners_scope.html">gitlab 文档</a>得到 authentication token(注意不能是 registration token)填写到 config-map.yaml。<br>◇ 将私有 gitlab 网站与 kubernetes 集群的连接信息填写到 config-map.yaml 文件样例。其中 concurrent 控制支持同时执行任务的数量，由于 Serverless 特性可以认为不受限制。然后 executor 的 cpu 与内存配置通过 cpu_limit、cpu_request、memory_limit、memory_request 控制。<br>◇ config.toml 中有关 [runners.kubernetes] 配置项的说明也在<a href="https://docs.gitlab.com/runner/executors/kubernetes/index.html">gitlab 文档</a>。<br>◇ config-map.yaml 完整内容如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: gitlab-runner-config</span><br><span class="line">data:</span><br><span class="line">  config.toml: |</span><br><span class="line">    concurrent = 10</span><br><span class="line">    check_interval = 0</span><br><span class="line">    [[runners]]</span><br><span class="line">      name = &quot;runner-on-k8s&quot;</span><br><span class="line">      url = $&#123;gitlab-url&#125;</span><br><span class="line">      token = $&#123;authentication token&#125;</span><br><span class="line">      executor = &quot;kubernetes&quot;</span><br><span class="line">      output_limit = 51200</span><br><span class="line">      [runners.kubernetes]</span><br><span class="line">        host = $&#123;k8s-connect-url&#125;</span><br><span class="line">        cert_file = &quot;/etc/gitlab-runner/tls.crt&quot;</span><br><span class="line">        key_file = &quot;/etc/gitlab-runner/tls.key&quot;</span><br><span class="line">        ca_file = &quot;/etc/gitlab-runner/ca.crt&quot;</span><br><span class="line">        namespace = &quot;default&quot;</span><br><span class="line">        pull_policy = &quot;if-not-present&quot;</span><br><span class="line">        cpu_limit = &quot;2&quot;</span><br><span class="line">        cpu_request = &quot;2&quot;</span><br><span class="line">        memory_limit = &quot;4Gi&quot;</span><br><span class="line">        memory_request = &quot;4Gi&quot;</span><br><span class="line">        helper_cpu_limit = &quot;0.5&quot;</span><br><span class="line">        helper_cpu_request = &quot;0.5&quot;</span><br><span class="line">        helper_memory_limit = &quot;1Gi&quot;</span><br><span class="line">        helper_memory_request  = &quot;1Gi&quot;</span><br><span class="line">        helper_image = &quot;gitlab/gitlab-runner-helper:x86_64-latest&quot;</span><br><span class="line">        [runners.kubernetes.pod_annotations]</span><br><span class="line">          &quot;k8s.aliyun.com/eci-image-cache&quot; = &quot;true&quot;</span><br><span class="line">        [runners.kubernetes.volumes]</span><br><span class="line">          [[runners.kubernetes.volumes.pvc]]</span><br><span class="line">            name = &quot;gitlab-runner-cache-pvc&quot;</span><br><span class="line">            mount_path = &quot;/cache&quot;</span><br><span class="line">            readonly = false</span><br><span class="line">          [[runners.kubernetes.volumes.secret]]</span><br><span class="line">            name = &quot;registry-auth-secret&quot;</span><br><span class="line">            mount_path = &quot;/kaniko/.docker&quot;</span><br><span class="line">            read_only = true</span><br><span class="line">            [runners.kubernetes.volumes.secret.items]</span><br><span class="line">              &quot;.dockerconfigjson&quot; = &quot;config.json&quot;</span><br><span class="line">          [[runners.kubernetes.volumes.secret]]</span><br><span class="line">            name = &quot;gitlab-credentials&quot;</span><br><span class="line">            mount_path = &quot;/root/gitlab-credentials&quot;</span><br><span class="line">            read_only = true</span><br></pre></td></tr></table></figure><p>◇ 执行&quot;kubectl apply -f config-map.yaml&quot;使生效。<br>◇ ConfigMap 创建成功后可在&quot;阿里云工作台页面集群详情-&gt;配置管理-&gt;配置项&quot;位置看到。</p><div class="img-container" style="width: 50%;"><img  src="/practice/%E5%9F%BA%E4%BA%8E%E9%98%BF%E9%87%8C%E4%BA%91ACK-Serverless%E6%90%AD%E5%BB%BA%E6%8C%89%E9%87%8F%E4%BB%98%E8%B4%B9%E7%9A%84gitlab-runner/configmap_in_workbench.png" class="" onerror="imgOnError(this);" data-fancybox ></div><h3 id="使用-deployment-部署-gitlab-runner-集群"><a href="#使用-deployment-部署-gitlab-runner-集群" class="headerlink" title="使用 deployment 部署 gitlab-runner 集群"></a>使用 deployment 部署 gitlab-runner 集群</h3><p>◆ 用于部署集群的 deployment 直接使用样例的 gitlab-runner-deployment.yaml 即可，完整内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: gitlab-runner</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: gitlab-runner</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: gitlab-runner</span><br><span class="line">      annotations:</span><br><span class="line">        k8s.aliyun.com/eci-image-cache: &quot;true&quot;</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - image: gitlab/gitlab-runner:latest</span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        name: gitlab-runner</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - mountPath: /etc/gitlab-runner</span><br><span class="line">          name: config</span><br><span class="line">      volumes:</span><br><span class="line">      - name: config</span><br><span class="line">        projected:</span><br><span class="line">          defaultMode: 420</span><br><span class="line">          sources:</span><br><span class="line">          - secret:</span><br><span class="line">              items:</span><br><span class="line">              - key: ca.crt</span><br><span class="line">                path: ca.crt</span><br><span class="line">              - key: tls.crt</span><br><span class="line">                path: tls.crt</span><br><span class="line">              - key: tls.key</span><br><span class="line">                path: tls.key</span><br><span class="line">              name: gitlab-runner-secret</span><br><span class="line">          - configMap:</span><br><span class="line">              items:</span><br><span class="line">              - key: config.toml</span><br><span class="line">                path: config.toml</span><br><span class="line">              name: gitlab-runner-config</span><br></pre></td></tr></table></figure><p>◆ 执行&quot;kubectl apply -f gitlab-runner-deployment.yaml&quot;完成 gitlab-runner 的部署。<br>◆ 部署成功后可在&quot;阿里云工作台页面集群详情-&gt;工作负载-&gt;容器组&quot;位置看到 gitlab-runner 的 pod。接下来在私有 gitlab 网站配置好 runner，当有 pipeline 任务执行时也可以看到相应 executor 的 pod。</p><div class="img-container" style="width: 60%;"><img  src="/practice/%E5%9F%BA%E4%BA%8E%E9%98%BF%E9%87%8C%E4%BA%91ACK-Serverless%E6%90%AD%E5%BB%BA%E6%8C%89%E9%87%8F%E4%BB%98%E8%B4%B9%E7%9A%84gitlab-runner/pods_in_workbench.png" class="" onerror="imgOnError(this);" data-fancybox ></div><h2 id="配置-gitlab-pipeline-中的相关问题与处理"><a href="#配置-gitlab-pipeline-中的相关问题与处理" class="headerlink" title="配置 gitlab pipeline 中的相关问题与处理"></a>配置 gitlab pipeline 中的相关问题与处理</h2><h3 id="artifacts-与-cache"><a href="#artifacts-与-cache" class="headerlink" title="artifacts 与 cache"></a>artifacts 与 cache</h3><p>♂ artifacts 与 cache 的区别在 gitlab 文档(https://docs.gitlab.com/ee/ci/caching/#how-cache-is-different-from-artifacts)里有说明。<br>♂ 当前 gitlab-runner 的方案中，考虑到 artifacts 存储位置是 gitlab 所在远程主机，而 cache 存储位置在每个 executor 的本地磁盘(通过将 NAS 挂载到每个 executor 上实现了 cache 内容的共享)，特别当需缓存内容比较大的时候，使用 cache 优于 artifacts。<br>♂ cache 没有 artifacts 那样的自动过期删除机制，对于打包结果这种每次存储路径不同的 cache，可在 after_script 阶段增加脚本以针对 cache key 清理不再使用的 cache 内容。示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">.dist-cache: &amp;dist-cache</span><br><span class="line">  key: $CI_PIPELINE_ID</span><br><span class="line">  paths:</span><br><span class="line">    - ./dist</span><br><span class="line"></span><br><span class="line">stages:</span><br><span class="line">  - build</span><br><span class="line">  - deploy</span><br><span class="line"></span><br><span class="line">build-job:</span><br><span class="line">  stage: build</span><br><span class="line">  script:</span><br><span class="line">    - echo &#x27;build&#x27;;</span><br><span class="line">  cache:</span><br><span class="line">    - &lt;&lt;: *dist-cache</span><br><span class="line">      policy: pull-push</span><br><span class="line">  allow_failure: false</span><br><span class="line"></span><br><span class="line">deploy-job:</span><br><span class="line">  stage: deploy</span><br><span class="line">    image:</span><br><span class="line">    name: gcr.io/kaniko-project/executor:v1.14.0-debug</span><br><span class="line">    entrypoint: [&#x27;&#x27;]</span><br><span class="line">  script:</span><br><span class="line">    - echo &#x27;build and push docker image based on cache&#x27;;</span><br><span class="line">  after_script:</span><br><span class="line">    - rm -rf /cache/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME/$CI_PIPELINE_ID*;</span><br><span class="line">  cache:</span><br><span class="line">    - &lt;&lt;: *dist-cache</span><br><span class="line">      policy: pull</span><br><span class="line">  dependencies: [build-job]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="build-docker-镜像"><a href="#build-docker-镜像" class="headerlink" title="build docker 镜像"></a>build docker 镜像</h3><p>♀ 对于 docker 镜像的构建与推送，采用配置更简单的 kaniko 方式，根据参考文档[3]，已经在之前 ConfigMap 中配置 docker 仓库 secret 的 mountPath 到&quot;&#x2F;kaniko&#x2F;.docker&#x2F;config.json&quot;。<br>♀ kaniko 镜像是个特别精简的 linux，不适合在其中配置打包环境。于是将打包与 docker 操作拆分到不同 job，打包结果通过上步 cache 的方式共享到 kaniko 镜像对应的容器中。<br>♀ 使用 kaniko 的 deploy-job 的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.echo-variables: &amp;echo-variables</span><br><span class="line">  - echo &quot;CI_PIPELINE_ID:&quot; $CI_PIPELINE_ID;</span><br><span class="line"></span><br><span class="line">deploy-job:</span><br><span class="line">  stage: deploy</span><br><span class="line">  image:</span><br><span class="line">    name: gcr.io/kaniko-project/executor:v1.14.0-debug</span><br><span class="line">    entrypoint: [&#x27;&#x27;]</span><br><span class="line">  script:</span><br><span class="line">    - /kaniko/executor</span><br><span class="line">      --context &quot;$&#123;CI_PROJECT_DIR&#125;&quot;</span><br><span class="line">      --dockerfile &quot;./Dockerfile&quot;</span><br><span class="line">      --destination &quot;$&#123;registry_dist&#125;&quot;</span><br><span class="line">  before_script:</span><br><span class="line">    - *echo-variables</span><br><span class="line">  after_script:</span><br><span class="line">    - rm -rf /cache/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME/$CI_PIPELINE_ID*;</span><br><span class="line">  cache:</span><br><span class="line">    - &lt;&lt;: *dist-cache</span><br><span class="line">      policy: pull</span><br><span class="line">  dependencies: [build-job]</span><br></pre></td></tr></table></figure><h3 id="git-ssh-鉴权"><a href="#git-ssh-鉴权" class="headerlink" title="git ssh 鉴权"></a>git ssh 鉴权</h3><p>▲ git ssh 信息的 mountPath 直接指定到&quot;&#x2F;root&#x2F;.ssh&quot;的时候遇到了如下问题：<br>（1）gitlab-runner 的 config.toml 配置中[runners.kubernetes.volumes.secret]不支持指定 mout 文件的 mode，使用 id_rsa 文件做 ssh 鉴权会报错：&quot;Permissions 0644 for &#39;&#x2F;root&#x2F;.ssh&#x2F;id_rsa&#39; are too open. This private key will be ignored&quot;。<br>（2）即使将配置中[runners.kubernetes.volumes.secret]的 read_only 设置为 false，对 id_rsa 执行 chmod 操作也报错&quot;chmod: changing permissions of &#39;&#x2F;root&#x2F;.ssh&#x2F;id_rsa&#39;: Read-only file system&quot;。<br>▲ 于是在 ConfigMap 中将 mountPath 指定到了&quot;&#x2F;root&#x2F;gitlab-credentials&quot;，之后在 pipeline 里再将文件从&quot;&#x2F;root&#x2F;gitlab-credentials&quot;拷贝到&quot;&#x2F;root&#x2F;.ssh&quot;并设置文件 mode。<br>▲ 如下示例定义一个初始化 git 鉴权文件的锚点供需要时引用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.prepare-git: &amp;prepare-git</span><br><span class="line">  - set +e;cat /root/.ssh/known_hosts;if [[ $? -ne 0 ]]; then</span><br><span class="line">    mkdir /root/.ssh;cat /root/gitlab-credentials/id_rsa &gt; /root/.ssh/id_rsa;chmod 400 /root/.ssh/id_rsa;</span><br><span class="line">    cp /root/gitlab-credentials/id_rsa.pub /root/gitlab-credentials/known_hosts /root/.ssh/;</span><br><span class="line">    fi;set -e;</span><br><span class="line">  - ssh -T git@$&#123;git_domain&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol><li><a href="https://developer.aliyun.com/article/773024?spm=a2c6h.13066369.question.5.3f623d588KEIEN">从零入门 Serverless | 教你 7 步快速构建 GitLab 持续集成环境</a></li><li><a href="https://docs.gitlab.com/">gitlab 官方 doc</a></li><li><a href="https://www.pachamamita.de/posts/kubernetes/kaniko-gitlab-runner/">kubernetes executor 上支持 docker 命令</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;方案说明&quot;&gt;&lt;a href=&quot;#方案说明&quot; class=&quot;headerlink&quot; title=&quot;方案说明&quot;&gt;&lt;/a&gt;方案说明&lt;/h2&gt;&lt;p&gt;◆ 由于 CI&amp;#x2F;CD 的非持续运行而运行期间又需要较高系统资源的特性，符合 ACK Serverless 按资源使</summary>
      
    
    
    
    <category term="实践总结" scheme="https://congzhou09.github.io/categories/practice/"/>
    
    
    <category term="ACK Serverless" scheme="https://congzhou09.github.io/tags/ACK-Serverless/"/>
    
    <category term="gitlab" scheme="https://congzhou09.github.io/tags/gitlab/"/>
    
  </entry>
  
  <entry>
    <title>&lt;State of GPT&gt;理解</title>
    <link href="https://congzhou09.github.io/knowledge/State-of-GPT-%E7%90%86%E8%A7%A3.html"/>
    <id>https://congzhou09.github.io/knowledge/State-of-GPT-%E7%90%86%E8%A7%A3.html</id>
    <published>2024-05-08T11:00:57.000Z</published>
    <updated>2025-03-19T13:37:34.642Z</updated>
    
    <content type="html"><![CDATA[<p>▲ 对 Microsoft Build 2023 上 Andrej Karpathy 演讲<a href="https://www.youtube.com/watch?v=bZQun8Y4L2A&t=1229s">State of GPT</a>的学习整理。<br>▲ <a href="https://karpathy.ai/stateofgpt.pdf">演讲 PPT 地址</a>。</p><h3 id="GPT-Assistant-是如何训练得到的"><a href="#GPT-Assistant-是如何训练得到的" class="headerlink" title="GPT Assistant 是如何训练得到的"></a>GPT Assistant 是如何训练得到的</h3><p>◇ 训练过程按先后顺序分为自左至右的 4 个阶段：Pretraining、Supervised Finetuning、Reward Modeling、Reinforcement Learning。<br>◇ 每个阶段都涉及 3 项内容：dataset、algorithm、model，其中 model 是通过 dataset+algorithm 训练得到的。</p><div class="img-container" style="width: 98%;">    <img  src="/knowledge/State-of-GPT-%E7%90%86%E8%A7%A3/training-pipeline.png" class="" onerror="imgOnError(this);" data-fancybox ></div><h4 id="Pretraining"><a href="#Pretraining" class="headerlink" title="Pretraining"></a>Pretraining</h4><p>◇ 预训练阶段几乎占了整个训练 99% 的运算性能与运算时间。长达数月，其他三种阶段都属于微调，训练仅消耗数天甚至数小时。<br>◇ 预训练得到的模型称为 base model。base model 不同于 assistant model，用于内容预测生成而不是回答问题。<br>◇ 预训练数据有多种来源，例如 Meta 公司的 LLaMA 模型的数据来源如下图。既有网络爬取数据，也有高质量数据集。</p><div class="img-container" style="width: 75%;">    <img  src="/knowledge/State-of-GPT-%E7%90%86%E8%A7%A3/dataset-of-base-model.png" class="" onerror="imgOnError(this);" data-fancybox ></div><p>◇ 数据集内容在使用前会通过 tokenization 被转换成整数序列。</p><div class="img-container" style="width: 80%;">    <img  src="/knowledge/State-of-GPT-%E7%90%86%E8%A7%A3/tokenization.png" class="" onerror="imgOnError(this);" data-fancybox ></div><p>◇ LLaMA 相比 GPT-3 更擅长对大量文本数据做深入理解语义的任务（如阅读理解与问答），GPT 的优势是对写作、对话、翻译等各种通用任务都表现好。下图是 LLaMA 与 GPT-3 的训练参数的对比，其中 vocabulary size 表示训练数据包含的不重复词汇量，context length 表示训练的上下文长度，parameters 表示训练用到的参数数量，trained on tokens 表示训练数据转换成的 token 数量，可见 LLaMA 在 parameter 和 vocabulary 方面的数量更少但在 trained on tokens 方面的数量更多。模型表现受训练数据多个维度参数的影响。</p><div class="img-container" style="width: 95%;">    <img  src="/knowledge/State-of-GPT-%E7%90%86%E8%A7%A3/params-of-gpt-vs-llama.png" class="" onerror="imgOnError(this);" data-fancybox ></div><p>◇ 大致训练过程：训练数据被放到数组(B,T)，行数 B 表示输入分为多少批，列数 T 表示最大上下文长度。数组的每一行包含多条数据序列，各条序列之间有约定好的分隔符。训练目标是让 transformer 神经网络能够在任意单元格(以图中绿格为例)根据当前及其左侧所有单元格趋于准确地推断出红色单元格的内容。</p><div class="img-container" style="width: 75%;">    <img  src="/knowledge/State-of-GPT-%E7%90%86%E8%A7%A3/base-model-training-process.png" class="" onerror="imgOnError(this);" data-fancybox ></div><p>◇ 相较于传统的 NLP 模型，由于此处的 base model 在预训练过程中理解了大量文本结构与概念，针对特定任务对其进行微调时仅需较少的标注数据就能达到很好的性能。而从 GPT-2 开始，人们发现仅通过 prompt 而无需 finetuning 就能让 base model 较好完成某些特定任务，由此开启了“prompting over finetuning”的时代。</p><p>◇ GPT-2 的 base model 公布在官方 GitHub 仓库，GPT-3 的 base model 可通过官方 api 使用模型&quot;Devanshi&quot;调用，GPT-4 的 base model 没有发布。当前最好的 base model 是 LLaMA，但目前未支持商用。</p><p>◇ 下图是当前各模型信息。</p><div class="img-container" style="width: 98%;">    <img  src="/knowledge/State-of-GPT-%E7%90%86%E8%A7%A3/current-models.png" class="" onerror="imgOnError(this);" data-fancybox ></div><h4 id="SFT（Supervised-finetuning）"><a href="#SFT（Supervised-finetuning）" class="headerlink" title="SFT（Supervised finetuning）"></a>SFT（Supervised finetuning）</h4><p>◆ 这一阶段的算法不变，只是数据集改成了 1-10 万数量的高质量&quot;prompt+response&quot;的问答示例，以向 assistant model 的方向训练。<br>◆ 训练结果模型称为 SFT model。</p><h4 id="RLHF（reinforcement-learning-from-human-feedback-）"><a href="#RLHF（reinforcement-learning-from-human-feedback-）" class="headerlink" title="RLHF（reinforcement learning from human feedback ）"></a>RLHF（reinforcement learning from human feedback ）</h4><p>□ RLHF 由 Reward modeling 和 Reinforcement learning 两个阶段组成。<br>□ Reward modeling 阶段的数据集量级在 10-100 万，内容是：上阶段 SFT model 对同一个 prompt 回答的多次 response+人为指定的效果分数排序。以此指导模型能针对一个 prompt 给相应的 response 打分。此阶段得到的模型称为 RM model。<br>□ Reinforcement learning 阶段的数据集量级在 1-10 万，内容是：prompt+SFT model 的多次回答+RM model 对相应回答的打分。以此强化模型针对 prompt 给出分数更高的 response。<br>□ 经过 RLHF 得到的模型称为 RLHF model。ChatGPT 就属于 RLHF model。<br>□ RLHF 提高了模型的结果分数但也使其丧失了部分多样性(variation)，于是在已知 N 个目标输出样例并期望得到具有更多多样性输出的场景，可以考虑使用 base model。<br>□ https://lmsys.org 网站提供了大语言模型(LLM)的竞技场(https://chat.lmsys.org/)，并会定期发布排名结果到blog(如：https://lmsys.org/blog/2023-12-07-leaderboard/)，目前排名靠前的模型都是RLHF model。</p><h3 id="实践中如何有效使用-GPT-assistant"><a href="#实践中如何有效使用-GPT-assistant" class="headerlink" title="实践中如何有效使用 GPT assistant"></a>实践中如何有效使用 GPT assistant</h3><p>■ 不同于人类从问题到答案的思维过程，transformer 的&quot;think&quot;是 tokens 维度的，它得出答案的过程是不断得基于现有 token(s) 预测下个 token。因此，当问题的回答需要推理时，通过将问题拆分步骤(Chain-of-Thought)的方式减少问题中每个 token 需要推理的数量，能得到更好的答案。拆分方式有两种：<br>（1）prompt 中按照拆分步骤的方式提供一组问答样例<br>（2）prompt 中说明&quot;分步骤思考&quot;(“think step by step”)</p><div class="img-container" style="width: 60%;">    <img  src="/knowledge/State-of-GPT-%E7%90%86%E8%A7%A3/chain-of-thought.png" class="" onerror="imgOnError(this);" data-fancybox ></div><p>■ 当生成答案期间如果有一个 token 偏离了问题，transformer 不会返回检查纠正而是继续基于已生成 token 继续生成后续内容。但可以通过带上历史问答内容重新提问上次回答是否满足提问需求使它对上次回答检查并返回纠正后的回答。目前有称为&quot;Tree of Thoughts&quot;方向的研究，目的是将许多 prompts 与树检索算法结合以动态得到最优的生成答案从而避免出现需要纠正的情况。</p><div class="img-container" style="width: 90%;">    <img  src="/knowledge/State-of-GPT-%E7%90%86%E8%A7%A3/tree-of-thoughts.png" class="" onerror="imgOnError(this);" data-fancybox ></div><p>■ LLM 的&quot;心理癖好&quot;：LLM 仅倾向于模仿所有相关训练数据生成完整答案而不会对训练数据中不同级别的答案做区分，比如对于一个物理问题，训练数据中通常既有专家级别的答案也有学生级别的答案甚至还有开玩笑的答案，LLM 默认会同时模仿所有级别的答案，这时可通过设置“Let&#39;s work this out in a step by step way to be sure we have the right answer.”、“You&#39;re a leading expert on this topic.”、“Pretend you have IQ 120.”这样的 prompt 来排除对低质量答案的模仿。<br>■ 为 LLM 指定可以使用的 tools(or plugin) 的场景中，在 prompt 中告诉 LLM 不擅长对应 tool 的能力可以让 tool 的调用更准确，因为 LLM 并不知道它自己不擅长的方面。<br>■ 检索增强(retrieval-augmented)的 LLM，LLM 只有从训练数据得来的知识记忆(memory)，如果将检索得到的提问相关信息放入 LLM 的上下文窗口(可称为 working memory)就可以同时发挥两者优势得到更好的答案。当前出现的方案是将信息分块后存入向量存储(如 LlamaIndex)，针对提问先检索得到相关信息再将其组织成 prompt。<br>■ 在希望限制 LLM 按照固定模板格式输出结果的场景，可以使用<a href="https://github.com/guidance-ai/guidance">guidance</a>。<br>■ finetuning 的本质是更新模型的参数权重，涉及更多专业技术，已知优化策略与相关工具：<br>（1）Parameter Efficient Finetuning(PEFT)。PEFT 是深度学习领域的一种优化策略，目标是在微调过程中尽可能减少需要更新的参数数量，而让模型的大部分参数权重固定，从而大幅降低 finetuning 成本。工具如：LoRA。<br>（2）Low-precision inference(低精度推理)。低精度推理是深度学习领域的一种优化策略，通过降低模型权重和激活的精度，减少模型的内存占用和计算需求而提高运行速度，在模型训练&#x2F;微调完成后使用。结合前面 PEFT 只针对微调部分做低精度推理也可降低计算成本。工具如：bitsandbytes。<br>■ 目前的 LLM 适合应用在与人为监督相结合的低风险领域，如灵感、建议、copilot。</p><h3 id="来自-GPT-4-的激励"><a href="#来自-GPT-4-的激励" class="headerlink" title="来自 GPT-4 的激励"></a>来自 GPT-4 的激励</h3><div class="img-container" style="width: 95%;">    <img  src="/knowledge/State-of-GPT-%E7%90%86%E8%A7%A3/inspiration-from-gpt4.png" class="" onerror="imgOnError(this);" data-fancybox ></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;▲ 对 Microsoft Build 2023 上 Andrej Karpathy 演讲&lt;a href=&quot;https://www.youtube.com/watch?v=bZQun8Y4L2A&amp;t=1229s&quot;&gt;State of GPT&lt;/a&gt;的学习整理。&lt;br&gt;▲ &lt;a</summary>
      
    
    
    
    <category term="知识解惑" scheme="https://congzhou09.github.io/categories/knowledge/"/>
    
    
    <category term="GPT" scheme="https://congzhou09.github.io/tags/GPT/"/>
    
  </entry>
  
  <entry>
    <title>AFFiNE纯前端调试环境搭建</title>
    <link href="https://congzhou09.github.io/practice/AFFiNE%E7%BA%AF%E5%89%8D%E7%AB%AF%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html"/>
    <id>https://congzhou09.github.io/practice/AFFiNE%E7%BA%AF%E5%89%8D%E7%AB%AF%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</id>
    <published>2024-04-29T10:10:17.000Z</published>
    <updated>2025-03-19T13:37:34.604Z</updated>
    
    <content type="html"><![CDATA[<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>◇ <a href="https://github.com/toeverything/AFFiNE/">AFFiNE 项目</a>包含了前端和后端的代码。想要在本地仅调试 web 前端代码(包括 Cloud Workspace 的内容)，而无需配置与启动其中的后端部分。</p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>● 项目 package.json 文件提供的 dev 脚本已经提供了交互式命令行界面来启动本地 web 开发服务，其默认连接的后端是 http://localhost:3010，将连接目标改为官方网址(https://app.affine.pro/)对应的后端。</p><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><h4 id="修改本地-web-开发服务的配置"><a href="#修改本地-web-开发服务的配置" class="headerlink" title="修改本地 web 开发服务的配置"></a>修改本地 web 开发服务的配置</h4><p>◆ 项目 dev 脚本运行的是项目内的 @affine&#x2F;cli 包，它的配置文件位于：&quot;tools\cli\src\webpack\config.ts&quot;。<br>◆ 将配置文件内容中所有的&quot;target: &#39;http://localhost:3010&#39;&quot;改为&quot;target: &#39;https://app.affine.pro/&#39;&quot;，并添加&quot;changeOrigin: true&quot;和&quot;secure: false&quot;。<br>◆ 例如其中的{context: &#39;&#x2F;socket.io&#39;, ...}这条，修改后如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  context: &#x27;/socket.io&#x27;,</span><br><span class="line">  target: &#x27;https://app.affine.pro/&#x27;,</span><br><span class="line">  changeOrigin: true,</span><br><span class="line">  secure: false,</span><br><span class="line">  ws: true,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="启动本地-web-开发服务"><a href="#启动本地-web-开发服务" class="headerlink" title="启动本地 web 开发服务"></a>启动本地 web 开发服务</h4><p>■ 运行&quot;yarn dev&quot;启动本地 web 开发服务。<br>■ 浏览器进入本地开发页面：http://localhost:8080。</p><h4 id="在官方网站上登录"><a href="#在官方网站上登录" class="headerlink" title="在官方网站上登录"></a>在官方网站上登录</h4><p>● 要使用&quot;Cloud Workspace&quot;涉及到第三方网站的登录鉴权，由于官方网站后端 API 登录成功后的重定向地址是官方网站的地址，所以登录流程无法在本地开发环境完成。手动在官方网站(https://app.affine.pro/)上完成登录。<br>● 登录成功并进入&quot;Cloud Workspace&quot;之后，拷贝当前网址中的路径，如：&quot;https://app.affine.pro/workspace/xx-xx-xx/all&quot;对应的路径是&quot;/workspace/xx-xx-xx/all&quot;。<br>● 浏览器开发者工具中查看已登录官方网站下的 cookie 字段：affine_session。</p><h4 id="拷贝官网身份信息到本地"><a href="#拷贝官网身份信息到本地" class="headerlink" title="拷贝官网身份信息到本地"></a>拷贝官网身份信息到本地</h4><p>▲ 将上节中 affine_session 字段及值创建与拷贝到本地 cookie，其中的 domain 值使用与本地开发页面相同的&quot;localhost&quot;。</p><div class="img-container" style="width: 90%;">    <img  src="/practice/AFFiNE%E7%BA%AF%E5%89%8D%E7%AB%AF%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/create-cookie.png" class="" onerror="imgOnError(this);" data-fancybox ></div><p>▲ 在本地环境访问上节路径，如：&quot;http://localhost:8080/workspace/xx-xx-xx/all&quot;，就可以看到与官网相同的内容并调试前端代码了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h3&gt;&lt;p&gt;◇ &lt;a href=&quot;https://github.com/toeverything/AFFiNE/&quot;&gt;AFFiNE 项目&lt;/a&gt;包含了前端</summary>
      
    
    
    
    <category term="实践总结" scheme="https://congzhou09.github.io/categories/practice/"/>
    
    
    <category term="AFFiNE" scheme="https://congzhou09.github.io/tags/AFFiNE/"/>
    
  </entry>
  
  <entry>
    <title>GitHub的workflow中clone私有仓库</title>
    <link href="https://congzhou09.github.io/practice/GitHub%E7%9A%84workflow%E4%B8%ADclone%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93.html"/>
    <id>https://congzhou09.github.io/practice/GitHub%E7%9A%84workflow%E4%B8%ADclone%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93.html</id>
    <published>2024-04-18T11:44:40.000Z</published>
    <updated>2025-03-19T13:37:34.633Z</updated>
    
    <content type="html"><![CDATA[<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>◇ GitHub 的项目 A 中，某个子文件夹需从另一个私有项目 B 通过 git clone 得到，有了这个子文件夹，项目 A 的 workflow 中某 step 才能正确执行。</p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>◆ 使用 workflow 提供的 actions&#x2F;checkout@v4 来 clone 代码，为其指定鉴权 token 以实现对私有仓库的访问。</p><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><h4 id="鉴权-token-的获取"><a href="#鉴权-token-的获取" class="headerlink" title="鉴权 token 的获取"></a>鉴权 token 的获取</h4><p>■ 进入对项目 B 有访问权限的 GitHub 用户的 Settings 页面。<br>■ 进入 Developer Settings-&gt;Presonal access tokens-&gt;Tokens(classic)菜单，创建一个&quot;personal access token (classic)&quot;，期间指定有效期，以及勾选 clone 项目 B 所需权限相关的 scopes。</p><h4 id="配置-token-到项目-A"><a href="#配置-token-到项目-A" class="headerlink" title="配置 token 到项目 A"></a>配置 token 到项目 A</h4><p>■ 进入项目 A 的 Settings 页面。<br>■ 进入 Security-&gt;Secrets and variables-&gt;Actions 菜单，通过&quot;New repository secret&quot;按钮创建一个 secret，期间的 Secret 内容填写上一步的 token 值。</p><h4 id="workflow-配置-clone-项目-B"><a href="#workflow-配置-clone-项目-B" class="headerlink" title="workflow 配置 clone 项目 B"></a>workflow 配置 clone 项目 B</h4><p>■ 相应 workflow 的 yaml 配置文件中，在依赖于子文件夹的 step 之前增加一个 clone 项目 B 代码到子文件夹的 step，示例如下，将其中的&lt;&gt;值替换为真实值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- ...other steps</span><br><span class="line">  ...</span><br><span class="line">- name: Clone private repository</span><br><span class="line">    uses: actions/checkout@v4</span><br><span class="line">    with:</span><br><span class="line">      repository: &lt;organization or personal space&gt;/&lt;repository name&gt;</span><br><span class="line">      ref: &lt;branch name&gt;</span><br><span class="line">      token: $&#123;&#123;secrets.&lt;secret name&gt;&#125;&#125;</span><br><span class="line">      path: &lt;destination folder name of the git clone&gt;</span><br><span class="line">- ...other steps</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h3&gt;&lt;p&gt;◇ GitHub 的项目 A 中，某个子文件夹需从另一个私有项目 B 通过 git clone 得到，有了这个子文件夹，项目 A 的 wor</summary>
      
    
    
    
    <category term="实践总结" scheme="https://congzhou09.github.io/categories/practice/"/>
    
    
    <category term="GitHub" scheme="https://congzhou09.github.io/tags/GitHub/"/>
    
    <category term="workflow" scheme="https://congzhou09.github.io/tags/workflow/"/>
    
  </entry>
  
  <entry>
    <title>从技术角度看emoji表情</title>
    <link href="https://congzhou09.github.io/knowledge/%E4%BB%8E%E6%8A%80%E6%9C%AF%E8%A7%92%E5%BA%A6%E7%9C%8Bemoji%E8%A1%A8%E6%83%85.html"/>
    <id>https://congzhou09.github.io/knowledge/%E4%BB%8E%E6%8A%80%E6%9C%AF%E8%A7%92%E5%BA%A6%E7%9C%8Bemoji%E8%A1%A8%E6%83%85.html</id>
    <published>2023-07-13T01:09:23.000Z</published>
    <updated>2025-03-19T13:37:34.688Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>○ emoji 是个形状图形，通常以彩色卡通方式展现，内容涵盖表情、天气、食物、动植物、交通建筑等多种类别。emoji 能内嵌在文字段落中，拓宽了文字表达的界限。<br>○ emoji 最早于 1999 年出现在日本移动电话中，“emoji”这个词源自日语：絵 (え ≅ picture) 文字 (もじ ≅ written character)。<br>○ emoji 的内部表示方式有以下两种。使用字体字形方式时与其他字符一样通过编码让字体去解析与展示，此时的 emoji 更确切得称为&quot;emoji 字符&quot;。<br>（1）内置图形&lt;graphics&gt;方式。每个 emoji 对应一个图像数据。<br>（2）字体字形&lt;glyphs&gt;方式。每个 emoji 对应一种编码。<br>○ 随着 emoji 在世界范围内的流行，不同平台厂商的 emoji 无法互通的问题涌现，使得统一 emoji 集合与字符编码的需求不断增加，Unicode 联盟于 2007 年通过了在 Unicode 字符集里扩展 emoji 字符的提案，2009 年发布的 Unicode 5.2 首次明确添加了第一批作为 emoji 字符的 Unicode 字符，之后不断有新批次的 emoji 字符随着 Unicode 的新版本被添加进去。<br>○ 从 2018 年的&quot;Emoji 11.0&quot;开始，emoji 字符集版本号与 Unicode Standard 使用相同版本号同步发布。</p><div class="img-container" style="width: 50%;">    <img  src="/knowledge/%E4%BB%8E%E6%8A%80%E6%9C%AF%E8%A7%92%E5%BA%A6%E7%9C%8Bemoji%E8%A1%A8%E6%83%85/versions.png" class="" onerror="imgOnError(this);" data-fancybox ></div><p>○ <a href="https://www.unicode.org/emoji/charts/emoji-versions.html">这个表格</a>详细列出了每个版本分别新增了哪些 emoji。<br>○ 通常说的字符编码是字符在 Unicode 字符集内被分配的一个唯一的编码数值，这个数值称为代码点（code point）。代码点通常用 16 进制表示，如 emoji 笑脸的代码点是 U+1F600 。<br>○ 这个网站 <a href="https://emojipedia.org/">emojipedia</a> 可用于查看 emoji 表情的代码点组成。<br>○ emoji 字符涉及如下图中 6 个相关属性。</p><div class="img-container" style="width: 100%;">    <img  src="/knowledge/%E4%BB%8E%E6%8A%80%E6%9C%AF%E8%A7%92%E5%BA%A6%E7%9C%8Bemoji%E8%A1%A8%E6%83%85/emoji-character-properties.png" class="" onerror="imgOnError(this);" data-fancybox ></div><p>○ 上述相关属性，一个 emoji 字符可能同时有多个属性值为 Yes ，相应字符也有对应的名称，列举如下：<br>（1）emoji character。具有“Emoji”属性的字符，这类字符通常直接展示 emoji 内容。<br>（2）emoji presentation。具有“Emoji_Presentation”属性的字符，默认以多彩图形的 emoji 方式展示而不是文本方式。与此属性相关有两个变体选择器字符 VARIATION SELECTOR-15(U+FE0E) 和 VARIATION SELECTOR-16(U+FE0F) 分别用于显式指定前面字符的呈现方式为文本或多彩图形。两种展示方式的最大差别是：文本方式展示为单色且可由字体颜色控制变色，而多彩图形方式色彩多样且不受字体颜色控制。<br>（3）emoji modifier。具有“Emoji_Modifier”属性的字符，用于修改前面的 emoji 字符的外观或语义(如肤色、性别)。<br>（4）emoji modifier base。具有“Emoji_Modifier_Base”属性的字符，只有这些字符才支持被随后的 emoji modifier 修改。<br>（5）extended pictographic character。具有“Extended_Pictographic”属性的字符，该属性提供了字符分割的规则信息，确保 <a href="#emoji-%E5%BA%8F%E5%88%97%EF%BC%88emoji-Sequences%EF%BC%89">emoji 序列 ↓</a> 这种被多个代码点组成的 emoji 表情能在分词时被正确分割。<br>（6）emoji component。具有“Emoji_Component”属性的字符，用于组成 emoji 序列，这类字符可能是 emoji character 也可能自身不独立展示 emoji 内容甚至只是个普通基础字符。例如键帽表情符号 1️⃣ 的序列组成是 U+31 和 U+FE0F 和 U+20E3，对照 <a href="https://www.unicode.org/Public/UCD/latest/ucd/emoji/emoji-data.txt">emoji-data</a> 可知三个字符都是 emoji component，而其中 U+31 对应的数字 1 是个基础字符。再如中国国旗 🇨🇳 的序列组成是 U+1F1E8 和 U+1F1F3，两个地区标志(Regional Indicator)字符同属于 emoji component 和 emoji character 和 emoji presentation。再如女科学家 👩‍🔬 的序列组成是 U+1F469 和 U+200D 和 U+1F52C，其中第一第三个字符同时是 emoji character 和 extended pictographic character，而第二个字符仅是 emoji component。<br>○ emoji 字符集版本号有三个特殊值：E0.0 和 E0.6 和 E0.7。其中 E0.0 包含了所有版本的 emoji 字符集里的 emoji component 和非 emoji character 字符。E0.6 和 E0.7 分别包含了当初添加到 Unicode 6.0 和 Unicode 7.0 的 emoji 字符，当时的 emoji 字符集没有自己的版本号。</p><h3 id="显示外观"><a href="#显示外观" class="headerlink" title="显示外观"></a>显示外观</h3><p>■ Unicode 字符集里定义的<a href="https://www.unicode.org/Public/UCD/latest/ucd/emoji/emoji-data.txt">原始 emoji</a> 是下图这种黑白朴素样式（需将链接指向的 *.txt 文件下载到本地，再使用纯文本编辑器打开）。</p><div class="img-container" style="width: 80%;"><img  src="/knowledge/%E4%BB%8E%E6%8A%80%E6%9C%AF%E8%A7%92%E5%BA%A6%E7%9C%8Bemoji%E8%A1%A8%E6%83%85/character-in-unicode.png" class="" onerror="imgOnError(this);" data-fancybox ></div><p>■ 与其他 Unicode 字符一样，同一个 emoji 由于所用字体不同可以展示为不同的样式。emoji 的样式分为&quot;text presentation&quot;和&quot;emoji presentation&quot;两大类，这在前面 emoji 字符的 emoji presentation 属性部分有陈述。<br>■ 平时更经常看到的各种多彩图形样式是各平台厂商设计与提供的，从<a href="https://www.unicode.org/emoji/charts/full-emoji-list.html">这里</a>可以看到同一个 emoji 在不同平台厂商的外观。<br>■ 显示异常情况：当展示 emoji 的平台所支持 Unicode 版本低于某个 emoji 字符所在版本，这个字符将无法正常显示。</p><h3 id="emoji-序列（emoji-Sequences）"><a href="#emoji-序列（emoji-Sequences）" class="headerlink" title="emoji 序列（emoji Sequences）"></a>emoji 序列（emoji Sequences）</h3><p>♂ emoji 标准中存在多种序列，这些序列由两个或多个字符组成，每个序列展示为一个新的单独的表情符。<br>♂ emoji 字符与变体选择器字符(见上文)组成的序列称为呈现序列(emoji presentation sequence)。<br>♂ emoji modifier base 与 emoji modifier 组成的序列称为修饰序列(emoji modifier sequence)。<br>♂ 由两个 regional indicator character 组成的序列称为旗帜序列(emoji flag sequence)。<br>♂ 由表情字符和标签字符组成的序列称为标签序列(emoji tag sequence)。可用于组成标签序列的字符在<a href="https://www.unicode.org/reports/tr51/#valid-emoji-tag-sequences">这里</a>定义。<br>♂ 由[0-9#*]字符和键帽字符(U+FE0F 和 U+20E3)组成的序列称为键帽序列(emoji keycap sequence)。<br>♂ 通过 ZWJ 组合成的序列称为 ZWJ 序列。ZWJ 是 Zero Width Joiner（零宽连接器）的缩写。它是个特殊的 Unicode 不可见字符，编码为 U+200D。<br>♂ emoji ZWJ 序列就是通过 ZWJ 字符连接已有 emoji 字符形成的，用于表示一个合成的 emoji 字符。<br>♂ 举例：👩‍🔬（女科学家）是由女性符号（👩）和实验室设备符号（🔬）通过 ZWJ 连接而成。<br>♂ <a href="https://unicode.org/emoji/charts/emoji-zwj-sequences.html">这里</a>列出了当前所有 emoji ZWJ 序列。<br>♂ 因此我们看到的一个 emoji 图像的背后可能包含了多个 Unicode 字符。<br>♂ emoji 序列的存在使得统计 emoji 数量变得不容易，近期字符集版本都提供了 emoji counts 表格，以<a href="https://www.unicode.org/emoji/charts-15.0/emoji-counts.html">15.0 版本的 emoji counts 表格</a>为例，其从表情分类与实现结构两个维度做了数量统计，实现结构维度的术语解释在<a href="https://www.unicode.org/emoji/format.html#col-totals">这里</a>。</p><h3 id="肤色的实现"><a href="#肤色的实现" class="headerlink" title="肤色的实现"></a>肤色的实现</h3><p>♀ 对于展示人物和身体部位的 emoji，最初计划是像笑脸那样使用一致的非现实肤色(黄色或橙色)。随着肤色需求的增加，2015 年发布的 Unicode Version 8.0 中增加了如下 5 个修饰字符(symbol modifier character)。</p><div class="img-container" style="width: 80%;"><img  src="/knowledge/%E4%BB%8E%E6%8A%80%E6%9C%AF%E8%A7%92%E5%BA%A6%E7%9C%8Bemoji%E8%A1%A8%E6%83%85/emoji-modifier.png" class="" onerror="imgOnError(this);" data-fancybox ></div><p>♀ 其中的样例颜色是基于名为 Fitzpatrick scale（菲茨帕特里克肤色分类法）的皮肤学标准制定的，而且提供了相应的灰度色用于适应黑白色环境。<br>♀ 这几个 modifier 字符可独立显示，此时展示内容是样例颜色方块。当放在特定的 emoji 字符之后时，则组成一个修饰序列(emoji modifier sequence)，展示对应肤色的 emoji 内容。<br>♀ 常见支持换肤色的 emoji 种类有人物、身体部位、职业、运动，从字符属性上看是前面提到的 emoji modifier base 字符，标准规范中将它们统称为&quot;human emoji&quot;(非正式术语)。当 human emoji 后面没有 emoji modifier 时则展示与笑脸一样的非现实肤色。<br>♀ 实际应用中的带肤色 emoji 通常是直接选择的，而无需先选 human emoji 再选 emoji modifier。</p><h3 id="分类与顺序"><a href="#分类与顺序" class="headerlink" title="分类与顺序"></a>分类与顺序</h3><p>△ emoji 字符默认的分类和顺序定义在 Unicode 的 <a href="https://cldr.unicode.org/">CLDR</a> 中。CLDR(Common Locale Data Repository)是用于提供全球化和本地化数据的开放标准。<br>△ 分类和顺序详情提供在<a href="https://www.unicode.org/emoji/charts/emoji-ordering.html">这里</a>。</p><h3 id="名称与检索关键词"><a href="#名称与检索关键词" class="headerlink" title="名称与检索关键词"></a>名称与检索关键词</h3><p>♥ 与其他 Unicode 字符一样，每个 emoji 字符都有个正式名称(formal Unicode name)，这个名称是字符集内唯一的且不会随版本变更，即使随着发展最新含义与最初名称出现了偏差，比如 💃(U+1F483)的正式名称是 DANCER，现在的含义 woman dancing 是随着 🕺(man dancing)的加入而变化的。正式名称通常书写为全大写字母。<br>♥ 每个 emoji 字符有个 CLDR 短名称(CLDR short name)，通过单词或短语描述 emoji 的含义或特征。CLDR 短名称会随着新版本做必要的变更。<br>♥ emoji 序列由于其实现原理是多个字符的组合，因此就只有 CLDR 短名称而没有正式名称。<br>♥ CLDR 短名称在 CLDR 中也被称为 TTS 名(text-to-speech name)。<br>♥ CLDR 是多语言的，内容维护在 GitHub 且提供了多种数据格式，如 <a href="https://github.com/unicode-org/cldr">xml</a> 和 <a href="https://github.com/unicode-org/cldr-json">json</a>，短名称与检索关键词(keywords)位于其中的 &quot;annotations&quot; 文件夹，以语言名缩写作为子路径或文件名，如中文的 json 文件路径是：&quot;cldr-json&#x2F;cldr-annotations-full&#x2F;annotations&#x2F;zh&#x2F;annotations.json&quot;。<br>♥ CLDR 也提供了在线工具<a href="https://st.unicode.org/cldr-apps">survey-tool</a>，在页面左侧先选择语言再选择 Characters-&gt;分类就可以看到分类下各个 emoji 表情的短名称和搜索关键词了。</p><h3 id="推荐项目"><a href="#推荐项目" class="headerlink" title="推荐项目"></a>推荐项目</h3><p>▲ GitHub 上的 <a href="https://github.com/missive/emoji-mart">emoji-mart</a> 实现了 emoji 表情选择器，支持图片与 Unicode 字符两种方式，适合作为开发 emoji 表情相关内容的参考。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>◇<a href="https://www.unicode.org/reports/tr51/">Unicode® Technical Standard - Unicode Emoji</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h3&gt;&lt;p&gt;○ emoji 是个形状图形，通常以彩色卡通方式展现，内容涵盖表情、天气、食物、动植物、交通建筑等多种类别。emoji 能内嵌在文字段落中，</summary>
      
    
    
    
    <category term="知识解惑" scheme="https://congzhou09.github.io/categories/knowledge/"/>
    
    
    <category term="web" scheme="https://congzhou09.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>动态import引起的打包体积增大</title>
    <link href="https://congzhou09.github.io/problem/%E5%8A%A8%E6%80%81import%E5%BC%95%E8%B5%B7%E7%9A%84%E6%89%93%E5%8C%85%E4%BD%93%E7%A7%AF%E5%A2%9E%E5%A4%A7.html"/>
    <id>https://congzhou09.github.io/problem/%E5%8A%A8%E6%80%81import%E5%BC%95%E8%B5%B7%E7%9A%84%E6%89%93%E5%8C%85%E4%BD%93%E7%A7%AF%E5%A2%9E%E5%A4%A7.html</id>
    <published>2023-03-21T07:24:23.000Z</published>
    <updated>2025-03-19T13:37:34.699Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>◆ 正常情况下 webpack 的编译是从入口文件开始按照模块依赖关系仅对被依赖的文件做编译的。今天在某项目里增加了个模块文件写到一半保存而还没对其做 import ，但此时 webpackDevServer 就已经报出这个模块内的语法错误了。</p><h3 id="解决与总结"><a href="#解决与总结" class="headerlink" title="解决与总结"></a>解决与总结</h3><p>◇ 根据堆栈信息追到再上一级的报错位置，来到下面这个函数，由于把动态 import 封装到函数，传入函数的值是个变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">... ...</span><br><span class="line">function importFromPath(pathName) &#123;</span><br><span class="line">  ... ...</span><br><span class="line">  return import(`$&#123;pathName&#125;`);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>◇ 根据<a href="https://webpack.js.org/api/module-methods/#dynamic-expressions-in-import">webpack 文档</a>的说明并结合试验发现，此种情况下，该文件同层级及以下层级中的所有文件会被纳入 webpack 的编译与打包范围，从而导致了上述问题。</p><p>◇ 随着项目量级增加，当有更多不在依赖关系树上的文件通过此机制被引入后就会引起整体打包速度变慢和打包体积增大。所幸 webpack 针对 import()默认会创建一个新的 chunk 将其分离到单独的 bundle ，不会在打包结果部署后还影响其他模块的载入速度。</p><p>◇ webpack 提供了<a href="https://webpack.js.org/api/module-methods/#magic-comments">magic-comments</a>用于配置处理动态 import()的行为。其中的&quot;webpackInclude&quot;能限定搜索动态模块的范围，可以解决我的问题。</p><p>◇ 因此在 webapck 中使用&quot;import(<em>变量</em>)&quot;时最好增加&quot;webpackInclude&quot;注释，以防止无关文件对打包的影响。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;◆ 正常情况下 webpack 的编译是从入口文件开始按照模块依赖关系仅对被依赖的文件做编译的。今天在某项目里增加了个模块文件写到一半保存而</summary>
      
    
    
    
    <category term="问题解决" scheme="https://congzhou09.github.io/categories/problem/"/>
    
    
    <category term="webpack" scheme="https://congzhou09.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Base64编码与DataUrl</title>
    <link href="https://congzhou09.github.io/knowledge/Base64%E7%BC%96%E7%A0%81%E4%B8%8EDataUrl.html"/>
    <id>https://congzhou09.github.io/knowledge/Base64%E7%BC%96%E7%A0%81%E4%B8%8EDataUrl.html</id>
    <published>2022-12-31T13:58:56.000Z</published>
    <updated>2025-03-19T13:37:34.610Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Base64-编码"><a href="#Base64-编码" class="headerlink" title="Base64 编码"></a>Base64 编码</h4><p>◇ Base64 是个二进制转文本的编码方案，它将每 3 个 8bit 数据表示为 4 个使用 6bit 编码的 Base64 字符。<br>◇ Base64 是 Base 编码的一种，其他 Base 编码如：Base16、Base32，&quot;Base&quot;后的数字越小，用来编码的字符数量越少。<br>◇ Base 编码的使用场景是在某些仅支持文本(甚至仅支持有限数量的文本字符)的环境中存储或传输数据。<br>◇ Base 编码规则详细定义在 <a href="https://datatracker.ietf.org/doc/html/rfc4648">RFC4648</a>。<br>◇ Base64 编码的 6 个 bit 位，二进制值从 000000 到 111111 分别编码为字符“A-Z”，“a-z”，“0-9”，“+”，“&#x2F;” 。另外有个 padding 字符“&#x3D;”，当末尾 bit 组长度不够 24bit 的时候，用一个或两个“&#x3D;”标识编码前缺少几个 8bit 才够 24bit，从而在解码时能正确解码“&#x3D;”前的那个字符。<br>◇ 综上可得 Base64 编码结果有如下特性：<br>（0）Base64 编码结果中最多有 65 种字符。<br>（1）“&#x3D;”字符只可能出现在编码结果末尾，数量不会超过两个。<br>（2）编码结果的字符数量是 4 的倍数。<br>（3）编码后的结果字符如果使用 ASCII 编码存储或展示，由于每个 ASCII 字符占用 8bit 空间，也就是用每 8bit 存储原来数据的 6bit，所以占用存储空间大约是原数据的 8&#x2F;6&#x3D;4&#x2F;3 倍。</p><h4 id="Base64-示例"><a href="#Base64-示例" class="headerlink" title="Base64 示例"></a>Base64 示例</h4><h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h5><p>☆ 待编码数据是用 ASCII 编码的“Man”对应的二进制数据</p><p>● 编码前数据的二进制内容如下图。</p><div class="img-container" style="width: 80%;">    <img  src="/knowledge/Base64%E7%BC%96%E7%A0%81%E4%B8%8EDataUrl/string-bits.png" class="" onerror="imgOnError(this);" data-fancybox ></div><p>● 将每 24bit 分成 6bit 组，每个 6bit 组使用 Base64 字符表示如下，可得“TWFu”。</p><div class="img-container" style="width: 80%;">    <img  src="/knowledge/Base64%E7%BC%96%E7%A0%81%E4%B8%8EDataUrl/bits-to-base-character.png" class="" onerror="imgOnError(this);" data-fancybox ></div><h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h5><p>☆ 待编码数据是用 ASCII 编码的“Mana”对应的二进制数据</p><p>● 编码前二进制数据是示例 1 二进制内容后接“01100001”。<br>● 将每 24bit 分成 6bit 组，第 1 个 24bit 组与示例 1 一致。第 2 个 24bit 组中第 1 个 6bit 组是“011000”对应字符“Y”，第 2 个 6bit 组是“01”末尾填充 0 得到“010000”对应字符“Q”。由于第 2 个 24bit 组只有 8bit，还差两个 8bit 才够 24bit，所以使用两个 padding 字符标识。最终编码就是“TWFuYQ&#x3D;&#x3D;”。</p><h4 id="JS-中的-Base64-编码"><a href="#JS-中的-Base64-编码" class="headerlink" title="JS 中的 Base64 编码"></a>JS 中的 Base64 编码</h4><p>○ JS 提供了 <a href="https://developer.mozilla.org/en-US/docs/Web/API/btoa">btoa()</a> 函数用于将二进制字符串转为 Base64 字符串。例如调用 btoa(&quot;Mana&quot;)可得到&quot;TWFuYQ&#x3D;&#x3D;&quot;，即上述示例 2 的结果。另外有 atob()函数执行相反操作。<br>○ btoa() 函数将输入字符串中每个字符当做 1 字节二进制数据处理，如果输入字符串中包含有效长度超过 1 字节的字符，就会报异常错误。<br>○ JS 的字符是通过 UTF-16 编码的，每个字符占 2 字节空间，其中的 ASCII 字符虽然也占 2 字节，但仅第 1 个字节内是有效内容，第二个字节全零，所以 btoa()处理 ASCII 字符不会报异常。<br>○ 可以通过以下表达式取值长度是否大于 2 判断某字符有效长度是否超过 1 字节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;string&gt;.charCodeAt(0).toString(16)</span><br></pre></td></tr></table></figure><h4 id="DataUrl"><a href="#DataUrl" class="headerlink" title="DataUrl"></a>DataUrl</h4><p>♂ Base64 编码的一个应用场景是在 HTML 或 CSS 文件中内嵌图片、SourceMap 等二进制资源，内嵌通过 DataUrl 实现。<br>♂ DataUrl 是种特殊的 url，它将数据内容直接嵌入在 url 里而不需要额外的外部文件。它以&quot;data:&quot;开头，包含如下 4 个部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</span><br></pre></td></tr></table></figure><p>♂ 其中 &lt;mediatype&gt; 是一个 MIME 类型字符串，标识 data 内容的格式，取值如“image&#x2F;jpeg”，“application&#x2F;x-www-form-urlencoded”，如果省略则按照“text&#x2F;plain;charset&#x3D;US-ASCII”处理。<br>♂ 当有“;base64”时表示 data 是经过 Base64 编码的。</p><h4 id="DataUrl-示例"><a href="#DataUrl-示例" class="headerlink" title="DataUrl 示例"></a>DataUrl 示例</h4><h5 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1"></a>示例 1</h5><p>☆ webpack 的 devtool 配置项</p><p>■ devtool 配置项的“inline-”和“eval-”两个前缀的含义是将 SourceMap 嵌入在打包文件中。<br>■ “inline-”方式，以“inline-source-map”为例，每个 bundle 对应一个 SourceMap，附加到整个 bundle 文件的末尾。<br>■ “eval-”方式，以“eval-source-map”为例，每个模块对应一个 SourceMap，附加到每个模块 eval 包裹内部的末尾。此种情况下，二次编译时能做到模块级 SourceMap 的单独替换，因此在 webpack dev rebuild 时更有速度优势。</p><div class="img-container" style="width: 70%;">    <img  src="/knowledge/Base64%E7%BC%96%E7%A0%81%E4%B8%8EDataUrl/data-url-as-source-mapping-url.png" class="" onerror="imgOnError(this);" data-fancybox ></div><h5 id="示例-2-1"><a href="#示例-2-1" class="headerlink" title="示例 2"></a>示例 2</h5><p>☆ webpack 的 url-loader</p><p>■ url-loader 的 “<a href="https://www.npmjs.com/package/url-loader#options">options</a>” 提供了一个 “limit” 配置项，当文件大于这个配置项值时执行 file-loader 的行为，否则便将资源转换成 DataUrl 嵌入到引入位置。<br>■ url-loader 和 file-loader 自 webpack5 起被“<a href="https://webpack.js.org/guides/asset-modules/#general-asset-type">module.rules.type</a>”配置项替代。</p><h5 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h5><p>☆ 占用空间最小的 base64 图片的 DataUrl</p><p>■ web 页面中有时需要一个有效的 <img  onerror="imgOnError(this);" data-fancybox > 元素占位，通常将其 src 属性设置为如下 DataUrl 内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data:image/gif;base64,R0lGODlhAQABAIAAAAAAAAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==</span><br></pre></td></tr></table></figure><p>■ 这个字符串中的 Base64 编码内容是一个 1x1 像素的透明 GIF 图片的数据。</p><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p>◆ <a href="https://en.wikipedia.org/wiki/Base64">Base64 wiki</a><br>◆ <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs">MDN Data URLs</a><br>◆ <a href="https://webpack.js.org/configuration/devtool/#devtool">webpack devtool</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;Base64-编码&quot;&gt;&lt;a href=&quot;#Base64-编码&quot; class=&quot;headerlink&quot; title=&quot;Base64 编码&quot;&gt;&lt;/a&gt;Base64 编码&lt;/h4&gt;&lt;p&gt;◇ Base64 是个二进制转文本的编码方案，它将每 3 个 8bit 数据表示为 </summary>
      
    
    
    
    <category term="知识解惑" scheme="https://congzhou09.github.io/categories/knowledge/"/>
    
    
    <category term="Base64" scheme="https://congzhou09.github.io/tags/Base64/"/>
    
    <category term="DataUrl" scheme="https://congzhou09.github.io/tags/DataUrl/"/>
    
  </entry>
  
  <entry>
    <title>阿里低代码开源项目学习-项目初识</title>
    <link href="https://congzhou09.github.io/knowledge/%E9%98%BF%E9%87%8C%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-%E9%A1%B9%E7%9B%AE%E5%88%9D%E8%AF%86.html"/>
    <id>https://congzhou09.github.io/knowledge/%E9%98%BF%E9%87%8C%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-%E9%A1%B9%E7%9B%AE%E5%88%9D%E8%AF%86.html</id>
    <published>2022-06-27T13:05:08.000Z</published>
    <updated>2025-03-19T13:37:34.779Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概念共识"><a href="#概念共识" class="headerlink" title="概念共识"></a>概念共识</h4><p>◻︎ 低代码平台的组成部分：物料体系、低代码设计器、工程化体系(如配置的存取、版本的管理、产物的打包发布)。<br>◻︎ 低代码设计器：低代码平台提供的用于可视化搭建页面或模块的地方，通常就在平台的&quot;&#x2F;edit&quot;页面。是低代码平台的核心。<br>◻︎ 低代码引擎：用于研发低代码设计器的框架，作用是帮助低代码平台开发者快速产出自定义的低代码设计器。总结为两点,（1）实现了低代码设计器基础功能;（2）提供了定制扩展能力。<br>◻︎ 阿里低代码引擎提供的定制扩展能力体现在如下几个方面：物料、插件、设置器。</p><div class="img-container" style="width: 80%;"><img  src="/knowledge/%E9%98%BF%E9%87%8C%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-%E9%A1%B9%E7%9B%AE%E5%88%9D%E8%AF%86/alc-engine-customization.png" class="" onerror="imgOnError(this);" data-fancybox ></div><p>◻︎ 低代码设计器插件是设计器中的自定义按钮和图标，支持两种形式：（1）PanelDock，展示图标，内容在展开面板中展示（2）Widget，内容直接展示。</p><h4 id="涉及到的仓库"><a href="#涉及到的仓库" class="headerlink" title="涉及到的仓库"></a>涉及到的仓库</h4><p>●<a href="https://github.com/ice-lab/build-scripts/tree/stable/0.x">build-scripts</a>。项目使用的工程构建脚手架工具，基于 webpack，包名自 1.x 版本起从&quot;@alib&#x2F;build-scripts&quot;更名为&quot;build-scripts&quot;。<br>● <a href="https://github.com/alibaba/lowcode-engine">lowcode-engine</a>。低代码引擎，遵循<a href="https://developer.aliyun.com/ebook/7507">低代码引擎白皮书</a>介绍的设计思路。<br>●<a href="https://github.com/alibaba/lowcode-demo">lowcode-demo</a>。将引擎、设置器、插件、物料等组合起来的示例工程。<br>●<a href="https://github.com/alibaba/lowcode-materials">lowcode-materials</a>。包含 Demo 中使用的物料库(antd, fusion)。<br>●<a href="https://github.com/alibaba/lowcode-engine-ext">lowcode-engine-ext</a>。包含 Demo 中使用的设置器。<br>●<a href="https://github.com/alibaba/lowcode-plugins">lowcode-plugins</a>。包含 Demo 中使用的插件。</p><h4 id="build-scripts"><a href="#build-scripts" class="headerlink" title="build-scripts"></a>build-scripts</h4><p>■ 通过 build-scripts 组织的项目本质还是使用 webpack 生态(API 函数、loader、plugin、webpack-dev-server)。<br>■ 设计思路，将调试&amp;构建&amp;测试流程做了如下三个层级的抽象：<br>（1）将通用流程化的内容封装到 build-scripts 命令行(start-开发调试 &amp; build-打包 &amp; test-测试)。<br>（2）将针对特定场景及特性的通用配置与处理逻辑封装到 build-scripts 插件。<br>（3）通过本地自定义插件提供项目特有的个性化配置。<br>■ 以上(2)(3)体现在 build.json 文件内容中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;entry&quot;: &#123;</span><br><span class="line">    &quot;preview&quot;: &quot;./src/preview.tsx&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  ... ...</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    [</span><br><span class="line">      &quot;build-plugin-react-app&quot;</span><br><span class="line">    ],</span><br><span class="line">    ... ...</span><br><span class="line">    &quot;./build.plugin.js&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>■ 以下是<a href="https://github.com/alibaba/ice/tree/master/packages">官方提供的 build-scripts 插件</a>。支持发布自己的 build-scripts 插件。</p><div class="img-container" style="width: 20%;"><img  src="/knowledge/%E9%98%BF%E9%87%8C%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-%E9%A1%B9%E7%9B%AE%E5%88%9D%E8%AF%86/official-build-script-plugins.png" class="" onerror="imgOnError(this);" data-fancybox ></div><p>■ build-scripts 使用 <a href="https://www.npmjs.com/package/webpack-chain">webpack-chain</a> 管理 webpack 配置，最终通过 webpack-chain 的 toConfig()方法转为符合格式规则的配置内容传入内部 webpack 使用。本地自定义插件中修改配置也通过编写 webpack-chain 的过程化语句实现。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">module.exports = (&#123; onGetWebpackConfig, context &#125;) =&gt; &#123;</span><br><span class="line">  onGetWebpackConfig((config) =&gt; &#123;</span><br><span class="line">    ... ...</span><br><span class="line">    // 设置alias</span><br><span class="line">    config.resolve.alias.set(&#x27;@&#x27;, path.resolve(__dirname, &#x27;./src&#x27;));</span><br><span class="line"></span><br><span class="line">    // 修改publicPath</span><br><span class="line">    config.output.publicPath((process.env.PUBLIC_PATH || &#x27;&#x27;) + &#x27;/&#x27;);</span><br><span class="line"></span><br><span class="line">    // 定义常量</span><br><span class="line">    config.plugin(&#x27;define&#x27;).use(context.webpack.DefinePlugin, [</span><br><span class="line">      &#123;</span><br><span class="line">        &#x27;process.env.DEPLOY_ENV&#x27;: process.env.DEPLOY_ENV,</span><br><span class="line">      &#125;,</span><br><span class="line">    ]);</span><br><span class="line"></span><br><span class="line">    // 设置webpackDevServer的代理</span><br><span class="line">    config.devServer.proxy(&#123;</span><br><span class="line">      &#x27;/api&#x27;: &#123;</span><br><span class="line">        target: &#x27;https://api.service.com&#x27;,</span><br><span class="line">        changeOrigin: true,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    ... ...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="lowcode-engine"><a href="#lowcode-engine" class="headerlink" title="lowcode-engine"></a>lowcode-engine</h4><p>○ 项目通过 lerna 管理，功能模块以 npm 包的形式组织，各个 npm 包使用 build-scripts 管理。<br>○ 项目主要输出的包有三个：@alilc&#x2F;lowcode-engine、@alilc&#x2F;lowcode-react-renderer、@alilc&#x2F;lowcode-react-simulator-renderer。<br>○ @alilc&#x2F;lowcode-engine 是低代码引擎的核心包，也会依赖项目中的其他包，如@alilc&#x2F;lowcode-designer、@alilc&#x2F;lowcode-editor-core、@alilc&#x2F;lowcode-editor-skeleton。模块依赖与所属包的关系如下图。</p><div class="img-container" style="width: 80%;"><img  src="/knowledge/%E9%98%BF%E9%87%8C%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-%E9%A1%B9%E7%9B%AE%E5%88%9D%E8%AF%86/alilc-engin-core-composition.svg" class="" onerror="imgOnError(this);" data-fancybox ></div><p>○ 各模块作用的简要说明：</p><table><thead><tr><th>模块</th><th>作用</th></tr></thead><tbody><tr><td>pulgins</td><td>用于设计器定制内容(插件、设置器、物料)的动态引入</td></tr><tr><td>skeleton</td><td>注册管理插件</td></tr><tr><td>setters</td><td>注册管理设置器</td></tr><tr><td>material</td><td>注册管理物料</td></tr><tr><td>hotkey</td><td>绑定管理快捷键</td></tr><tr><td>event</td><td>自定义事件处理</td></tr><tr><td>project</td><td>管理编排功能相关的模型系统</td></tr><tr><td>config</td><td>负责配置的读写</td></tr></tbody></table><p>○ @alilc&#x2F;lowcode-react-renderer 是低代码设计器产物的渲染组件。<br>○ @alilc&#x2F;lowcode-react-simulator-renderer 是低代码设计器中的画布组件。</p><h4 id="lowcode-demo"><a href="#lowcode-demo" class="headerlink" title="lowcode-demo"></a>lowcode-demo</h4><p>■ 项目主要输出两类页面：（1）可视化编辑页面（2）可视化编辑页面产物的预览页面。<br>■ 项目入口如下，除了 “build.json” 中的 preview 之外，还有在“build.plugin.js”中动态写入的 scenarios 文件夹中各子文件夹。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  preview: [</span><br><span class="line">    &quot;src/preview.tsx&quot;, // 预览页面入口</span><br><span class="line">  ],</span><br><span class="line">  &quot;antd-pro-with-formily&quot;: [</span><br><span class="line">    &quot;src/scenarios/antd-pro-with-formily/index.ts&quot;,</span><br><span class="line">  ],</span><br><span class="line">  &quot;basic-antd&quot;: [</span><br><span class="line">    &quot;src/scenarios/basic-antd/index.ts&quot;,</span><br><span class="line">  ],</span><br><span class="line">  &quot;basic-formily&quot;: [</span><br><span class="line">    &quot;src/scenarios/basic-formily/index.ts&quot;,</span><br><span class="line">  ],</span><br><span class="line">  ... ... // scenarios文件夹中各个子文件夹，对应各场景的编辑页面</span><br><span class="line">  index: [</span><br><span class="line">    &quot;src/scenarios/index/index.ts&quot;, // 综合编辑页面，提供了场景切换功能</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="编辑页面"><a href="#编辑页面" class="headerlink" title="编辑页面"></a>编辑页面</h5><p>● 编辑页面首先使用官方提供的插件、设置器、物料库对引擎做了定制。其中动态异步加载的地方都通过 <a href="https://lowcode-engine.cn/docV2/ibh9fh#BJW5r">plugins.register()</a> 实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/** src/universal/plugin.tsx **/</span><br><span class="line"></span><br><span class="line">import AliLowCodeEngineExt from &#x27;@alilc/lowcode-engine-ext&#x27;; // 官方设置器</span><br><span class="line"></span><br><span class="line">import CodeGenPlugin from &#x27;@alilc/lowcode-plugin-code-generator&#x27;;</span><br><span class="line">... &#x27;@alilc/lowcode-plugin-xxxx&#x27;;</span><br><span class="line">import DataSourcePanePlugin from &#x27;@alilc/lowcode-plugin-datasource-pane&#x27;; // ...官方插件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">const &#123; setterMap, pluginMap &#125; = AliLowCodeEngineExt;</span><br><span class="line">setters.registerSetter(setterMap); // 注册设置器</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// 注册插件</span><br><span class="line">skeleton.add(&#123;</span><br><span class="line">  name: &#x27;saveSample&#x27;,</span><br><span class="line">  area: &#x27;topArea&#x27;,</span><br><span class="line">  type: &#x27;Widget&#x27;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    align: &#x27;right&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line">    content: &lt;Button onClick=&#123;() =&gt; saveSchema()&#125;&gt;保存到本地&lt;/Button&gt;,</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// 以资产包的方式注册物料库</span><br><span class="line">await material.setAssets(await injectAssets(assets));</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>● 其中的 assets 是使用&quot;资产包&quot;的形式描述的物料库，格式遵循<a href="https://developer.aliyun.com/ebook/7507/38536?spm=a2c6h.26392470.ebook-read.20.1a8819b9CnT1ZR">低代码引擎物料规范</a>，示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;packages&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;package&quot;: &quot;moment&quot;,</span><br><span class="line">      &quot;version&quot;: &quot;2.24.0&quot;,</span><br><span class="line">      &quot;urls&quot;: [</span><br><span class="line">        &quot;https://g.alicdn.com/mylib/moment/2.24.0/min/moment.min.js&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;library&quot;: &quot;moment&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">  ],</span><br><span class="line">  &quot;components&quot;: [</span><br><span class="line">     &#123;</span><br><span class="line">      &quot;exportName&quot;: &quot;AlilcLowcodeMaterialsMeta&quot;,</span><br><span class="line">      &quot;npm&quot;: &#123;</span><br><span class="line">        &quot;package&quot;: &quot;@alilc/lowcode-materials&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;url&quot;: &quot;https://alifd.alicdn.com/npm/@alilc/lowcode-materials@1.0.2/build/lowcode/meta.js&quot;,</span><br><span class="line">      &quot;urls&quot;: &#123;</span><br><span class="line">        &quot;default&quot;: &quot;https://alifd.alicdn.com/npm/@alilc/lowcode-materials@1.0.2/build/lowcode/meta.js&quot;,</span><br><span class="line">        &quot;design&quot;: &quot;https://alifd.alicdn.com/npm/@alilc/lowcode-materials@1.0.2/build/lowcode/meta.design.js&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">  ],</span><br><span class="line">   &quot;sort&quot;: &#123;</span><br><span class="line">    &quot;groupList&quot;: []</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>● 最终通过@alilc&#x2F;lowcode-engine 提供的 init()函数完成渲染，基本语法如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; init &#125; from &#x27;@alilc/lowcode-engine&#x27;;</span><br><span class="line"></span><br><span class="line">init(document.getElementById(&#x27;lce-container&#x27;), &#123;</span><br><span class="line">  ...options,</span><br><span class="line">&#125;, preference);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="预览页面"><a href="#预览页面" class="headerlink" title="预览页面"></a>预览页面</h5><p>○ 预览页面将&quot;schema+物料库描述&quot;渲染成页面。其中物料库描述就是&quot;资产包&quot;中的“packages”内容，schema 包含了组件树结构及相关配置信息，内容格式遵循<a href="https://developer.aliyun.com/ebook/7507/38535?spm=a2c6h.26392470.ebook-read.19.71db11ablYDVF1">低代码引擎搭建协议规范</a>，示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;componentsMap&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;package&quot;: &quot;@alifd/pro-layout&quot;,</span><br><span class="line">      &quot;version&quot;: &quot;1.0.1-beta.6&quot;,</span><br><span class="line">      &quot;exportName&quot;: &quot;Col&quot;,</span><br><span class="line">      &quot;main&quot;: &quot;lib/index.js&quot;,</span><br><span class="line">      &quot;destructuring&quot;: true,</span><br><span class="line">      &quot;subName&quot;: &quot;&quot;,</span><br><span class="line">      &quot;componentName&quot;: &quot;NextCol&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">  ],</span><br><span class="line">  &quot;componentsTree&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;componentName&quot;: &quot;Page&quot;,</span><br><span class="line">      &quot;id&quot;: &quot;node_dockcviv8fo1&quot;,</span><br><span class="line">      &quot;props&quot;: &#123; &quot;ref&quot;: &quot;outerView&quot;, &quot;style&quot;: &#123; &quot;height&quot;: &quot;100%&quot; &#125; &#125;,</span><br><span class="line">      &quot;fileName&quot;: &quot;/&quot;,</span><br><span class="line">      ...</span><br><span class="line">      &quot;children&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;componentName&quot;: &quot;NextPage&quot;,</span><br><span class="line">          &quot;id&quot;: &quot;node_ockzs2vw431&quot;,</span><br><span class="line">          &quot;props&quot;: &#123;</span><br><span class="line">            ...</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;children&quot;: ...</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;i18n&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>○ 最终是通过@alilc&#x2F;lowcode-react-renderer 完成渲染，基本语法如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import ReactRenderer from &#x27;@alilc/lowcode-react-renderer&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render((</span><br><span class="line">  &lt;ReactRenderer</span><br><span class="line">    schema=&#123;schema&#125;</span><br><span class="line">    components=&#123;components&#125;</span><br><span class="line">  /&gt;</span><br><span class="line">), document.getElementById(&#x27;root&#x27;));</span><br></pre></td></tr></table></figure><h4 id="关于设计器的定制实践"><a href="#关于设计器的定制实践" class="headerlink" title="关于设计器的定制实践"></a>关于设计器的定制实践</h4><p>▲ <a href="https://lowcode-engine.cn/site/docs/api/">API 文档</a><br>▲ <a href="https://developer.aliyun.com/ebook/7507/38525?spm=a2c6h.26392470.ebook-read.9.daef5e67Jr02Vm">starter 项目</a>，见白皮书中“定制插件”、“定制设置器”“定制物料”章节。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;概念共识&quot;&gt;&lt;a href=&quot;#概念共识&quot; class=&quot;headerlink&quot; title=&quot;概念共识&quot;&gt;&lt;/a&gt;概念共识&lt;/h4&gt;&lt;p&gt;◻︎ 低代码平台的组成部分：物料体系、低代码设计器、工程化体系(如配置的存取、版本的管理、产物的打包发布)。&lt;br&gt;◻︎ 低</summary>
      
    
    
    
    <category term="知识解惑" scheme="https://congzhou09.github.io/categories/knowledge/"/>
    
    
    <category term="低代码" scheme="https://congzhou09.github.io/tags/%E4%BD%8E%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript使用小贴士</title>
    <link href="https://congzhou09.github.io/handbook/TypeScript%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%B4%B4%E5%A3%AB.html"/>
    <id>https://congzhou09.github.io/handbook/TypeScript%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%B4%B4%E5%A3%AB.html</id>
    <published>2022-04-25T12:49:46.000Z</published>
    <updated>2025-03-19T13:37:34.663Z</updated>
    
    <content type="html"><![CDATA[<h3 id="环境配置相关"><a href="#环境配置相关" class="headerlink" title="环境配置相关"></a>环境配置相关</h3><p>■ 在还未手动安装 TypeScript 的情况下，操作系统或 IDE 很可能已经自带了 TypeScript。此时在手动安装了 TypeScript 之后如果不做相应的配置，系统命令行及 IDE 可能依旧使用原有的 TypeScript。</p><h4 id="系统命令行的配置"><a href="#系统命令行的配置" class="headerlink" title="系统命令行的配置"></a>系统命令行的配置</h4><p>▲Windows 系统默认在“C:\Program Files (x86)\Microsoft SDKs\TypeScript\1.0”目录下安装了 Typescript，且将此路径配置到了系统 path。导致问题：<br>（1）即使 npm -g 全局安装了最新 Typescript，运行“tsc --version”返回的仍然是老旧版本号。<br>（2）tsc 命令误报：&quot;error TS1005: &#39;;&#39; expected&quot;<br>▲ 解决办法是将上述目录文件和系统 path 里配置的路径都删掉。</p><h4 id="IDE-的配置"><a href="#IDE-的配置" class="headerlink" title="IDE 的配置"></a>IDE 的配置</h4><p>● 在任何一个&quot;*.ts&quot;文件中查看与跳转到某个原生 JS 对象成员函数定义所在的文件，如 Array 的 find()函数。默认跳转到的类型定义文件位于 VSCode 的安装目录下。<br>(MacOS 环境是&quot;&#x2F;Applications&#x2F;Visual Studio Code.app&#x2F;Contents&#x2F;Resources&#x2F;app&#x2F;extensions&#x2F;node_modules&#x2F;typescript&#x2F;lib&#x2F;lib.es2015.core.d.ts&quot;)</p><div class="img-container" style="width: 50%;flex-direction: row;">    <img  src="/handbook/TypeScript%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%B4%B4%E5%A3%AB/locate_to_primitive_js_file.png" class="" onerror="imgOnError(this);" data-fancybox ></div><p>● 因为通常我们在各项目范围内安装与使用特定版本的 TypeScript，所以需要指定上述 TypeScript 目录到当前项目的 node_modules 文件夹。通过为 VSCode 添加如下配置实现，保存 Reload 下窗口再次查看跳转函数定义所在文件跳转的就是当前项目的 node_modules 文件夹了，且在 VSCode 打开 ts 文件窗口的右下方状态栏可以看到当前 TypeScript 的版本号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;typescript.tsdk&quot;: &quot;node_modules/typescript/lib&quot;,</span><br></pre></td></tr></table></figure><div class="img-container" style="width: 50%;flex-direction: row;">   <img  src="/handbook/TypeScript%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%B4%B4%E5%A3%AB/vscode_rightbottom_toolbar.png" class="" onerror="imgOnError(this);" data-fancybox ></div><h3 id="项目配置相关"><a href="#项目配置相关" class="headerlink" title="项目配置相关"></a>项目配置相关</h3><h4 id="Node-项目"><a href="#Node-项目" class="headerlink" title="Node 项目"></a>Node 项目</h4><p>○ tsconfig.json 内容样例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    &quot;target&quot;: &quot;es5&quot;,                                  /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */</span><br><span class="line">    &quot;module&quot;: &quot;commonjs&quot;,                                /* Specify what module code is generated. */</span><br><span class="line">    &quot;rootDir&quot;: &quot;./src&quot;,                                  /* Specify the root folder within your source files. */</span><br><span class="line">    &quot;declaration&quot;: true,                              /* Generate .d.ts files from TypeScript and JavaScript files in your project. */</span><br><span class="line">    &quot;sourceMap&quot;: true,                                /* Create source map files for emitted JavaScript files. */</span><br><span class="line">    &quot;outDir&quot;: &quot;./lib&quot;,                                   /* Specify an output folder for all emitted files. */</span><br><span class="line">    &quot;esModuleInterop&quot;: true,                             /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables `allowSyntheticDefaultImports` for type compatibility. */</span><br><span class="line">    &quot;forceConsistentCasingInFileNames&quot;: true,            /* Ensure that casing is correct in imports. */</span><br><span class="line">    &quot;strict&quot;: true,                                      /* Enable all strict type-checking options. */</span><br><span class="line">    &quot;skipLibCheck&quot;: true                                 /* Skip type checking all .d.ts files. */</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>○ 安装@types&#x2F;node 以支持 Node 的 ts 类型定义。</p><h4 id="Web-项目"><a href="#Web-项目" class="headerlink" title="Web 项目"></a>Web 项目</h4><p>○ tsconfig.json 内容样例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    &quot;target&quot;: &quot;es5&quot;,                                     /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */</span><br><span class="line">    &quot;module&quot;: &quot;commonjs&quot;,                                /* Specify what module code is generated. */</span><br><span class="line">    &quot;lib&quot;: [&quot;dom&quot;, &quot;esnext&quot;]                             /* Specify library files to be included in the compilation. */,</span><br><span class="line">    &quot;jsx&quot;: &quot;react&quot;                                       /* Specify JSX code generation: &#x27;preserve&#x27;, &#x27;react-native&#x27;, &#x27;react&#x27;, &#x27;react-jsx&#x27; or &#x27;react-jsxdev&#x27;. */,</span><br><span class="line">    &quot;declaration&quot;: true,                                 /* Generate .d.ts files from TypeScript and JavaScript files in your project. */</span><br><span class="line">    &quot;strict&quot;: true,                                      /* Enable all strict type-checking options. */</span><br><span class="line">    &quot;forceConsistentCasingInFileNames&quot;: true,            /* Ensure that casing is correct in imports. */</span><br><span class="line">    &quot;skipLibCheck&quot;: true                                 /* Skip type checking all .d.ts files. */</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>○ react 项目安装@types&#x2F;react 和@types&#x2F;react-dom。<br>○ <a href="https://www.codegrepper.com/code-examples/typescript">ts 书写格式参考</a>。<br>○ <a href="https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example">react 各场景的 ts 书写格式参考（react-typescript-cheatsheet）</a></p><h5 id="webpack-项目的配置"><a href="#webpack-项目的配置" class="headerlink" title="webpack 项目的配置"></a>webpack 项目的配置</h5><p>◻︎ 支持 ts 语法的两种方式。<br>方式一：通过&quot;ts-loader&quot;实现对 ts 文件的类型检查与编译。<br>方式二：&quot;babel-loader&quot;通过配置“@babel&#x2F;preset-typescript”presets 也可以解析与编译 ts 语法。</p><p>◻︎ 两种方式的区别是：第二种方式，由于 babel 仅做解析和编译，不会做 ts 类型检查，进而不会在 webpack 命令行输出中报出类型检查错误。<a href="https://www.typescriptlang.org/docs/handbook/babel-with-typescript.html">官方详细说明</a>。</p><h3 id="第三方库的引入"><a href="#第三方库的引入" class="headerlink" title="第三方库的引入"></a>第三方库的引入</h3><p>▲ 第三方库的 ts 类型定义通常在名为“@types&#x2F;库名”的 npm 包中，可通过命令&quot;npm view @types&#x2F;库名&quot;查看该 npm 包是否存在。这种方式无需额外配置，TypeScript 会自动读取“node_modules&#x2F;@types”目录下的声明文件。</p><p>▲ 当没有对应第三方库的类型声明 npm 包的时候，需要手动书写*.d.ts 文件。然后有两种配置方式。<br>（1）在 tsconfig.json 配置中的 &quot;include&quot; 字段数组中增加文件完整路径。注意这里添加的路径不能是&quot;node_modules&quot;目录下的，会被 TypeScript 忽略。<br>（2）通过三斜线语句引入类型定义文件，示例如下。这种方式的配置与上一种不同，它仅对当前文件有效，当别的文件缺少这个声明时也需要书写引入语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 类型定义文件 &quot;./types/one.d.ts&quot;</span><br><span class="line">declare module &#x27;Module_Name&#x27; &#123;</span><br><span class="line">  export default (...)=&gt;any;</span><br><span class="line">  export class ...;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 引入类型定义文件</span><br><span class="line">/// &lt;reference path=&quot;./types/one.d.ts&quot; /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;环境配置相关&quot;&gt;&lt;a href=&quot;#环境配置相关&quot; class=&quot;headerlink&quot; title=&quot;环境配置相关&quot;&gt;&lt;/a&gt;环境配置相关&lt;/h3&gt;&lt;p&gt;■ 在还未手动安装 TypeScript 的情况下，操作系统或 IDE 很可能已经自带了 TypeScrip</summary>
      
    
    
    
    <category term="操作手册" scheme="https://congzhou09.github.io/categories/handbook/"/>
    
    
    <category term="TypeScript" scheme="https://congzhou09.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>特定项目下自动切换node到指定版本</title>
    <link href="https://congzhou09.github.io/practice/%E7%89%B9%E5%AE%9A%E9%A1%B9%E7%9B%AE%E4%B8%8B%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2node%E5%88%B0%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC.html"/>
    <id>https://congzhou09.github.io/practice/%E7%89%B9%E5%AE%9A%E9%A1%B9%E7%9B%AE%E4%B8%8B%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2node%E5%88%B0%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC.html</id>
    <published>2022-04-12T13:20:42.000Z</published>
    <updated>2025-03-19T13:37:34.743Z</updated>
    
    <content type="html"><![CDATA[<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>○ 使用 nvm 管理本地多版本 Node.js，默认使用版本 14。某个项目当前仅支持版本 10，每次执行&quot;nvm use&quot;手动切换太麻烦了。<br>○ 想到&quot;.npmrc&quot;文件可以指定仅对项目生效的配置，对应在网上找&quot;.nvmrc&quot;找到了解决办法。</p><h3 id="操作步骤-MacOS环境"><a href="#操作步骤-MacOS环境" class="headerlink" title="操作步骤(MacOS环境)"></a>操作步骤(MacOS环境)</h3><p>以场景需求为例的操作步骤如下：</p><p>■ 命令行进入需指定 node 版本的项目下，先使用&quot;nvm use v10.17.0&quot;切换到目标版本，再执行&quot;node -v &gt; .nvmrc&quot;将 node 版本号保存到&quot;.nvmrc&quot;文件，如果只限制第一级版本号可将文件内容改为&quot;v10&quot;。<br>■ 添加命令行初始化脚本。如果使用的是 zsh 命令行，通过&quot;vim $HOME&#x2F;.zshrc&quot;追加如下脚本内容到文件。其他类型命令行脚本参考<a href="https://github.com/nvm-sh/nvm#deeper-shell-integration">nvm 的 README.md 中说明</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># nvm check when zsh initializing</span><br><span class="line">autoload -U add-zsh-hook</span><br><span class="line">load-nvmrc() &#123;</span><br><span class="line">  local node_version=&quot;$(nvm version)&quot;</span><br><span class="line">  local nvmrc_path=&quot;$(nvm_find_nvmrc)&quot;</span><br><span class="line"></span><br><span class="line">  if [ -n &quot;$nvmrc_path&quot; ]; then</span><br><span class="line">    local nvmrc_node_version=$(nvm version &quot;$(cat &quot;$&#123;nvmrc_path&#125;&quot;)&quot;)</span><br><span class="line"></span><br><span class="line">    if [ &quot;$nvmrc_node_version&quot; = &quot;N/A&quot; ]; then</span><br><span class="line">      nvm install</span><br><span class="line">    elif [ &quot;$nvmrc_node_version&quot; != &quot;$node_version&quot; ]; then</span><br><span class="line">      nvm use</span><br><span class="line">    fi</span><br><span class="line">  elif [ &quot;$node_version&quot; != &quot;$(nvm version default)&quot; ]; then</span><br><span class="line">    echo &quot;Reverting to nvm default version&quot;</span><br><span class="line">    nvm use default</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line">add-zsh-hook chpwd load-nvmrc</span><br><span class="line">load-nvmrc</span><br><span class="line"></span><br><span class="line"># nvm check when running cd command</span><br><span class="line">cd-nvm() &#123;</span><br><span class="line">  builtin cd &quot;$@&quot;</span><br><span class="line">  if [[ -f .nvmrc ]]; then</span><br><span class="line">    load-nvmrc</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line">alias cd=&#x27;cd-nvm&#x27;</span><br><span class="line"></span><br><span class="line"># changes take effect</span><br><span class="line">source ~/.bash_profile</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>■ 以上脚本实现了&quot;从项目目录直接打开命令行&quot;和&quot;通过 cd 命令进入项目目录&quot;两种情况下自动切换 node 到 nvm 默认版本或&quot;.nvmrc&quot;文件指定版本。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>▲<a href="https://stackoverflow.com/questions/57110542/how-to-write-a-nvmrc-file-which-automatically-change-node-version">How to write a .nvmrc file which automatically change node version</a><br>▲<a href="https://stackoverflow.com/questions/29653036/automatically-switch-to-correct-version-of-node-based-on-project">Automatically switch to correct version of Node based on project</a><br>▲<a href="https://github.com/nvm-sh/nvm#deeper-shell-integration">nvm README.md</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h3&gt;&lt;p&gt;○ 使用 nvm 管理本地多版本 Node.js，默认使用版本 14。某个项目当前仅支持版本 10，每次执行&amp;quot;nvm use&amp;qu</summary>
      
    
    
    
    <category term="实践总结" scheme="https://congzhou09.github.io/categories/practice/"/>
    
    
    <category term="Node.js" scheme="https://congzhou09.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>浏览器新开Tab读不到sessionStorage的问题</title>
    <link href="https://congzhou09.github.io/practice/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%96%B0%E5%BC%80Tab%E8%AF%BB%E4%B8%8D%E5%88%B0sessionStorage%E7%9A%84%E9%97%AE%E9%A2%98.html"/>
    <id>https://congzhou09.github.io/practice/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%96%B0%E5%BC%80Tab%E8%AF%BB%E4%B8%8D%E5%88%B0sessionStorage%E7%9A%84%E9%97%AE%E9%A2%98.html</id>
    <published>2021-12-24T12:32:56.000Z</published>
    <updated>2025-03-19T13:37:34.732Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>▲ 上半年解决&quot;url 传参方式, 因参数过长导致 url 过长&quot;问题时想到使用 sessionStorage 缓存参数，今天突然发现这个办法在新项目里不管用：虽然新开的 Tab 与源页面在相同的域，但源页面设置的 sessionStorage 在新开 Tab 中读取不到。</p><p>▲ 网上查找如何在 Tab 之间共享 sessionStorage 的方案，排名第一的搜索结果居然是<a href="https://stackoverflow.com/questions/20325763/browser-sessionstorage-share-between-tabs">通过 localStorage 做中转</a>。</p><h3 id="分析与解决"><a href="#分析与解决" class="headerlink" title="分析与解决"></a>分析与解决</h3><p>■ 印象里 sessionStorage 与 localStorage 的区别只有生命周期不同，查看<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage">MDN 中对 sessionStorage 的说明</a>才发现自己认知的漏洞，从以下截图描述（特别是红框位置）可见 sessionStorage 还有以下特性：<br>（1）浏览器打开新 Tab 的时候会为其单独创建一份新的 sessionStorage。<br>（2）相同域下不同 Tab 的 sessionStorage 是相互独立的。</p><div class="img-container" style="width:90%;">  <img  src="/practice/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%96%B0%E5%BC%80Tab%E8%AF%BB%E4%B8%8D%E5%88%B0sessionStorage%E7%9A%84%E9%97%AE%E9%A2%98/mdn_description.png" class="" onerror="imgOnError(this);" data-fancybox ></div><p>■ 但为何自己当时可以在新开的 Tab 读取到源页面的 sessionStorage 呢，从截图中蓝框位置描述看到了线索：当前页面的 sessionStorage 是有办法拷贝到新开 Tab 中的。</p><p>■ 查找拷贝 sessionStorage 的方法看到了<a href="https://stackoverflow.com/questions/57330335/why-is-sessionstorage-preserved-across-multiple-tabs">设置 rel&#x3D;&quot;opener&quot;的方法</a>，将其中提问者给出的<a href="https://stackblitz.com/edit/session-storage?file=index.js">demo</a>修改如下就可以在新开 Tab 读到 sessionStorage 啦。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function openPageInNewTab() &#123;</span><br><span class="line">  const link = document.createElement(&#x27;a&#x27;);</span><br><span class="line">  link.target = &#x27;_blank&#x27;;</span><br><span class="line">  link.href = &#x27;/&#x27;;</span><br><span class="line">  link.setAttribute(&#x27;visibility&#x27;, &#x27;hidden&#x27;);</span><br><span class="line">  link.setAttribute(&#x27;rel&#x27;, &#x27;opener&#x27;); // 增加此行</span><br><span class="line">  document.body.appendChild(link);</span><br><span class="line">  link.click();</span><br><span class="line">  link.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="额外信息"><a href="#额外信息" class="headerlink" title="额外信息"></a>额外信息</h3><p>○ Chrome 从版本 89 开始，打开新 Tab 时不再默认将当前 sessionStorage 拷贝到新开 Tab，详见：<a href="https://chromestatus.com/feature/5679997870145536#details">Chrome Feature: Stop cloning sessionStorage for windows opened with noopener</a></p><p>○ 查了之前项目代码，那时候是使用 window.open()函数实现的新开 Tab。经测试依然有效，也就是当前通过 window.open()函数打开新 Tab 时，仍然会将当前 sessionStorage 拷贝到新开 Tab。</p><p>○ 携带 rel&#x3D;&quot;opener&quot;要注意使用场景，防止<a href="https://juejin.cn/post/6844903485289267214">安全类问题</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;▲ 上半年解决&amp;quot;url 传参方式, 因参数过长导致 url 过长&amp;quot;问题时想到使用 sessionStorage 缓存参数</summary>
      
    
    
    
    <category term="实践总结" scheme="https://congzhou09.github.io/categories/practice/"/>
    
    
    <category term="HTML规范" scheme="https://congzhou09.github.io/tags/HTML%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>Ant Design的Upload组件定制</title>
    <link href="https://congzhou09.github.io/handbook/Ant-Design%E7%9A%84Upload%E7%BB%84%E4%BB%B6%E5%AE%9A%E5%88%B6.html"/>
    <id>https://congzhou09.github.io/handbook/Ant-Design%E7%9A%84Upload%E7%BB%84%E4%BB%B6%E5%AE%9A%E5%88%B6.html</id>
    <published>2021-11-15T06:37:29.000Z</published>
    <updated>2025-03-19T13:37:34.607Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>■Ant Design 官方文档中对于限制数量、上传接口请求与响应、下载等功能的自定义实现方法描述得不详细，在此做下记录。<br>■ 实现功能如下：<br>（1）上传接口报错时弹出错误信息(由于后端接口统一将错误信息与错误码封装在 http 码为 200 的 body 中，所以需要上传接口请求与响应的自定义)；<br>（2）限制上传文件数量 10 个；<br>（3）选择文件对话框中可选多个文件；<br>（4）限制每个文件大小不超过 20M；<br>（5）上传成功后展示的文件列表项可点击下载；<br>（6）onChange 传出值格式:[{fileName: string, fileUrl: string}]</p><h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><p>□ 代码实例如下，经调试发现无论 onSuccess 传入怎样的参数格式，下载功能都需要自己实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useCallback, useEffect, useRef, useState &#125; from &#x27;react&#x27;;</span><br><span class="line">import &#123; Upload, message, Button &#125; from &#x27;antd&#x27;;</span><br><span class="line">import axios from &#x27;axios&#x27;;</span><br><span class="line"></span><br><span class="line">const FileUpload = (&#123;</span><br><span class="line">  maxFileSize = 20,</span><br><span class="line">  maxFileCount = 10,</span><br><span class="line">  onChange,</span><br><span class="line">&#125;) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  // 文件大小限制</span><br><span class="line">  const maxFileSizeRef = useRef();</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    // M转byte</span><br><span class="line">    maxFileSizeRef.current = maxFileSize * 1024 * 1024;</span><br><span class="line">  &#125;, [maxFileSize]);</span><br><span class="line"></span><br><span class="line">  // 文件数量记录</span><br><span class="line">  const [fileListCount, setFileListCount] = useState(0);</span><br><span class="line">  const [isDisabled, setIsDisabled] = useState(false);</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    if (fileListCount &gt;= maxFileCount) &#123;</span><br><span class="line">      setIsDisabled(true);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      setIsDisabled(false);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [fileListCount, maxFileCount]);</span><br><span class="line"></span><br><span class="line">  // &quot;文件uid-下载url&quot;映射记录</span><br><span class="line">  const [downloadUrls, setDownloadUrls] = useState(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">  // onChange格式转换</span><br><span class="line">  const customOnChange = useCallback(</span><br><span class="line">    (&#123; fileList &#125;) =&gt; &#123;</span><br><span class="line">      const outputValue = [];</span><br><span class="line">      fileList.forEach((one) =&gt; &#123;</span><br><span class="line">        if (one.status === &#x27;done&#x27;) &#123;</span><br><span class="line">          outputValue.push(&#123;</span><br><span class="line">            fileName: one.name,</span><br><span class="line">            fileUrl: downloadUrls[one.uid],</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      // console.log(&#x27;onChange: &#x27;, outputValue);</span><br><span class="line">      onChange &amp;&amp; onChange(outputValue);</span><br><span class="line">    &#125;,</span><br><span class="line">    [onChange, downloadUrls]</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;Upload</span><br><span class="line">      onChange=&#123;customOnChange&#125;</span><br><span class="line">      showUploadList=&#123;&#123;</span><br><span class="line">        showDownloadIcon: true,</span><br><span class="line">      &#125;&#125;</span><br><span class="line">      beforeUpload=&#123;(file, fileList) =&gt; &#123;</span><br><span class="line">        const newCount = fileListCount + fileList.length;</span><br><span class="line">        if (file.size &gt; maxFileSizeRef.current) &#123;</span><br><span class="line">          message.warn(`文件&#x27;$&#123;file.name&#125;&#x27;超过文件大小限制: $&#123;maxFileSize&#125;M`);</span><br><span class="line">          return Upload.LIST_IGNORE;</span><br><span class="line">        &#125; else if (newCount &gt; maxFileCount) &#123;</span><br><span class="line">          message.warn(`超过最大上传数量: $&#123;maxFileCount&#125;`);</span><br><span class="line">          return Upload.LIST_IGNORE;</span><br><span class="line">        &#125; else if (newCount === maxFileCount) &#123;</span><br><span class="line">          setIsDisabled(true);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;&#125;</span><br><span class="line">      customRequest=&#123;(allData) =&gt; &#123;</span><br><span class="line">        setFileListCount(fileListCount + 1);</span><br><span class="line">        const &#123; onProgress, onSuccess, onError &#125; = allData;</span><br><span class="line">        const reqFormData = new FormData();</span><br><span class="line">        // 通过组件的data属性传入的额外请求参数，根据接口要求定制</span><br><span class="line">        Object.keys(allData.data).forEach((oneKey) =&gt; &#123;</span><br><span class="line">          reqFormData.append(oneKey, allData.data[oneKey]);</span><br><span class="line">        &#125;);</span><br><span class="line">        reqFormData.append(&#x27;file&#x27;, allData.file);</span><br><span class="line">        axios(&#123;</span><br><span class="line">          method: &#x27;post&#x27;,</span><br><span class="line">          url: &#x27;/common/file/upload&#x27;,</span><br><span class="line">          data: reqFormData,</span><br><span class="line">          onUploadProgress: (progress) =&gt; &#123;</span><br><span class="line">            // 上传进度条</span><br><span class="line">            const progNum = progress.loaded / progress.total;</span><br><span class="line">            onProgress(&#123; percent: progNum &#125;);</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">          .then((resData) =&gt; &#123;</span><br><span class="line">            setDownloadUrls((prevState) =&gt; &#123;</span><br><span class="line">              return &#123;</span><br><span class="line">                ...prevState,</span><br><span class="line">                [allData.file.uid]: resData.url,</span><br><span class="line">              &#125;;</span><br><span class="line">            &#125;);</span><br><span class="line">            onSuccess(&#123; url: resData.url &#125;);</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch((error) =&gt; &#123;</span><br><span class="line">            onError(error);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;&#125;</span><br><span class="line">      multiple=&#123;true&#125;</span><br><span class="line">      data=&#123;(file) =&gt; &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          typeId: 2,</span><br><span class="line">          fileName: file.name,</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;&#125;</span><br><span class="line">      onRemove=&#123;() =&gt; &#123;</span><br><span class="line">        setFileListCount(fileListCount - 1);</span><br><span class="line">      &#125;&#125;</span><br><span class="line">      openFileDialogOnClick=&#123;!isDisabled&#125;</span><br><span class="line">      onDownload=&#123;(file) =&gt; &#123;</span><br><span class="line">        window.open(downloadUrls[file.uid]);</span><br><span class="line">      &#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &#123;isDisabled ? (</span><br><span class="line">        &lt;span style=&#123;&#123; color: &#x27;#ff7700&#x27; &#125;&#125;&gt;</span><br><span class="line">          已达到最大上传数量: &#123;maxFileCount&#125;个</span><br><span class="line">        &lt;/span&gt;</span><br><span class="line">      ) : (</span><br><span class="line">        &lt;Button&gt;上传&lt;/Button&gt;;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/Upload&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">... ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>●<a href="https://github.com/react-component/upload#customrequest">rc-upload文档</a><br>●<a href="https://blog.csdn.net/weixin_34413802/article/details/88722992">前端通过 axios 和 FormData 实现文件上传功能遇到的坑</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;■Ant Design 官方文档中对于限制数量、上传接口请求与响应、下载等功能的自定义实现方法描述得不详细，在此做下记录。&lt;br&gt;■ 实现功</summary>
      
    
    
    
    <category term="操作手册" scheme="https://congzhou09.github.io/categories/handbook/"/>
    
    
    <category term="antd" scheme="https://congzhou09.github.io/tags/antd/"/>
    
  </entry>
  
  <entry>
    <title>git合并分支两种方式:rebase与merge</title>
    <link href="https://congzhou09.github.io/practice/git%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F-rebase%E4%B8%8Emerge.html"/>
    <id>https://congzhou09.github.io/practice/git%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F-rebase%E4%B8%8Emerge.html</id>
    <published>2021-02-16T03:55:15.000Z</published>
    <updated>2025-03-19T13:37:34.667Z</updated>
    
    <content type="html"><![CDATA[<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>○ 当前 git 分支状态如下示意图，本地 dev 分支从 master 分支的 C2 版本切出并经过 2 次提交到达 C4 版本，远程 master 分支经过 1 次提交到达 C5 版本。<br>○ 此时要在本地将 dev 分支合并到 master。</p><div class="img-container" style="width: 60%;">  <img  src="https://congzhou09.gitlab.io/drawio_storage/blog/git_merge_and_rebase_scene.svg" alt="git merge与rebase场景图,来自congzhou09.gitlab.io" onerror="imgOnError(this);" data-fancybox ></div><h3 id="merge-方式"><a href="#merge-方式" class="headerlink" title="merge 方式"></a>merge 方式</h3><p>♂ 直接使用 merge 命令合并 dev 分支到 master 分支，由于 C2 不是 master 最新版本，将把 C2 到 C4 的修改合并到 master 最新版本 C5 并自动生成一条 commit。<br>♂ 两个分支上的 commit 记录在 log 中的顺序与 pull 与 merge 操作先后有关。先 pull 再 merge 是先合并远程修改再合并本地修改，先 merge 再 pull 是先合并本地修改再合并远程修改，从思路上都说得通。<br>♂ 本地切到 master 分支后，先 pull master 分支，再 merge dev 分支的 log 结果如下图，其中的 parent1 是 C5。</p><div class="img-container" style="width: 80%;">  <img  src="/practice/git%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F-rebase%E4%B8%8Emerge/first_pull_then_merge.png" class="" onerror="imgOnError(this);" data-fancybox ></div><p>♂ 本地切到 master 分支后，先 merge dev 分支，再 pull master 分支的 log 结果如下图，远程 master 上的新提交 C5 被显示为被合并分支，其中的 parent1 是 C4。</p><div class="img-container" style="width: 80%;">  <img  src="/practice/git%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F-rebase%E4%B8%8Emerge/first_merge_then_pull.png" class="" onerror="imgOnError(this);" data-fancybox ></div><p>♂ merge 方式自动生成的那条 commit 记录了合并结果分别与两个分支最新版本的差异。<br>♂ 使用 merge 方式合并分支，merge 与 pull 顺序只影响两分支 commit 记录的顺序，不影响合并完的代码结果。</p><h3 id="rebase-方式"><a href="#rebase-方式" class="headerlink" title="rebase 方式"></a>rebase 方式</h3><p>♀ rebase 思路是将 dev 分支上的原先基于的 C2 更新为基于 C5，将对原基准版本后的每个 commit(C3 和 C4)执行更新基准过程，每个 commit 可能都要解决一次冲突，rebase 完成之后分支状态示意图如下，此时再将 dev 分支合并到 master 由于基准版本就是 master 最新版本就只是简单的同步了。</p><div class="img-container" style="width: 60%;">  <img  src="https://congzhou09.gitlab.io/drawio_storage/blog/git_merge_and_rebase_rebaseok.svg" alt="git merge与rebase场景图,来自congzhou09.gitlab.io" onerror="imgOnError(this);" data-fancybox ></div><p>♀ “git rebase master”和“git rebase --continue”命令对应在 TortoiseGit 的操作界面如下，其中 Branch 是执行 rebase 的分支，Upstream 是 base 所在分支。</p><div class="img-container" style="width: 70%;">  <img  src="/practice/git%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F-rebase%E4%B8%8Emerge/tortoisegit_rebase.png" class="" onerror="imgOnError(this);" data-fancybox ></div><p>♀ rebase 的 log 结果如下图，经过 rebase 之后，C3 与 C4 的 commit log 记录的修改内容将变成基于 C5 的修改，相应 SHA 码也会更改。</p><div class="img-container" style="width: 80%;">  <img  src="/practice/git%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F-rebase%E4%B8%8Emerge/first_rebase_then_merge.png" class="" onerror="imgOnError(this);" data-fancybox ></div><h3 id="rebase-方式与-merge-方式区别"><a href="#rebase-方式与-merge-方式区别" class="headerlink" title="rebase 方式与 merge 方式区别"></a>rebase 方式与 merge 方式区别</h3><p>□ 执行 rebase 期间可能需要解决多次冲突。<br>□ rebase 的 log 结果中没有单独生成一条记录合并的 commit，log graph 是线性没有分叉的。<br>□ rebase 的 log 结果中 commit 记录固定按照合并到 master 分支的先后顺序排列。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>● <a href="https://www.jianshu.com/p/6960811ac89c">你真的懂 git rebase 吗-简书</a><br>● <a href="https://git-scm.com/docs">git 官方 Reference 手册</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h3&gt;&lt;p&gt;○ 当前 git 分支状态如下示意图，本地 dev 分支从 master 分支的 C2 版本切出并经过 2 次提交到达 C4 版本，远程 m</summary>
      
    
    
    
    <category term="实践总结" scheme="https://congzhou09.github.io/categories/practice/"/>
    
    
    <category term="git" scheme="https://congzhou09.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>本地自签名HTTPS环境搭建</title>
    <link href="https://congzhou09.github.io/practice/%E6%9C%AC%E5%9C%B0%E8%87%AA%E7%AD%BE%E5%90%8DHTTPS%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html"/>
    <id>https://congzhou09.github.io/practice/%E6%9C%AC%E5%9C%B0%E8%87%AA%E7%AD%BE%E5%90%8DHTTPS%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</id>
    <published>2021-02-13T02:23:50.000Z</published>
    <updated>2025-03-19T13:37:34.717Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前置知道"><a href="#前置知道" class="headerlink" title="前置知道"></a>前置知道</h3><p>○OpenSSL是为实现SSL和TLS提供支持的工具包；<br>○HTTPS证书只能绑定域名而不能绑定某个IP；<br>○1.1.1版本OpenSSL命令用法的<a href="https://www.openssl.org/docs/man1.1.1/man1/">官方文档</a>；<br>○操作环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Windows 10</span><br><span class="line">openssl 1.1.1(通过&quot;openssl version&quot;命令查看)；</span><br><span class="line">nginx 1.17.1</span><br></pre></td></tr></table></figure><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><h4 id="添加本地域名"><a href="#添加本地域名" class="headerlink" title="添加本地域名"></a>添加本地域名</h4><p>●定义本地域名以&quot;blog.congzhou.com&quot;为例，将域名解析添加到“Windows\System32\drivers\etc”下的hosts文件，hosts文件中的域名不支持通配符；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 blog.congzhou.com</span><br></pre></td></tr></table></figure><h4 id="生成HTTPS所需私钥与证书"><a href="#生成HTTPS所需私钥与证书" class="headerlink" title="生成HTTPS所需私钥与证书"></a>生成HTTPS所需私钥与证书</h4><p>●执行如下命令创建本地模拟CA的私钥与CA根证书，分别生成&quot;RootCA.key&quot;和&quot;RootCA.pem&quot;两个文件，其中用到的国家编码在<a href="https://www.iban.com/country-codes">这里</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">openssl req -x509 -nodes -new -days 365 -newkey rsa:2048 -keyout RootCA.key -out RootCA.pem -subj &quot;/C=CN/CN=YCZ-Root-CA&quot;</span><br><span class="line"></span><br><span class="line">/******</span><br><span class="line">  * 命令解读</span><br><span class="line">  * openssl-req主要用于创建与处理证书请求(CSR, certificate signing request)，也用于创建自签名方式的根证书</span><br><span class="line">  * 参数解读</span><br><span class="line">  * -x509:  输出证书而不是CSR</span><br><span class="line">  * -nodes: 生成的私钥不做加密</span><br><span class="line">  * -new: 当没有-key参数时将使用-newkey和-pkeyopt参数生成私钥</span><br><span class="line">  * -days: 证书有效天数，默认30天</span><br><span class="line">  * -newkey rsa:2048 : 生成2048bit长度的rsa格式私钥</span><br><span class="line">  * -subj: 设置证书涉及到的字段(称为证书的subject)值，/C是CountryName编码，/CN是CommonName即CA机构名称</span><br><span class="line">****/</span><br></pre></td></tr></table></figure><p>●执行如下命令生成上一步pem证书的对应crt格式的证书文件&quot;RootCA.crt&quot;，Windows中crt扩展名的证书文件右键菜单才有&quot;安装&quot;选项；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -inform pem -in RootCA.pem -out RootCA.crt</span><br><span class="line"></span><br><span class="line">/******</span><br><span class="line">  * 命令解读</span><br><span class="line">  * openssl-x509用途较多，可用于转换证书格式和为CSR签名</span><br><span class="line">  * 参数解读</span><br><span class="line">  * -inform 输入证书的格式，取值为pem或der，默认值pem，pem是base64编码的文本格式，der是DER(Distinguished Encoding Rules)编码的二进制格式</span><br><span class="line">  * -outform 输出证书的格式，默认与输入整数的格式一致</span><br><span class="line">****/</span><br></pre></td></tr></table></figure><p>●执行如下命令创建本地域名网站私钥与网站证书req，分别生成&quot;congzhou.key&quot;和&quot;congzhou.csr&quot;两个文件，这里将证书签到域名&quot;*.congzhou.com&quot;方便以后也可以给其他二级子域名使用；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -nodes -newkey rsa:2048 -keyout congzhou.key -out congzhou.csr -subj &quot;/C=CN/ST=Beijing/L=Beijing/O=Example  Company Limited/CN=*.congzhou.com&quot;</span><br><span class="line"></span><br><span class="line">/******</span><br><span class="line">  * 参数解读</span><br><span class="line">  * -new: 生成一个新的CSR</span><br><span class="line">  * -subj参数使用到的subject含义：/ST是StateOrProvinceName，/L是Locality，/O是Organization。/CN用于网站时就是网站的域名，支持&quot;*.example.com&quot;形式的通配符，但只能填写一条</span><br><span class="line">  *</span><br><span class="line">  *</span><br><span class="line">  * Subject Alternative Name（简称SAN，也称&quot;使用者备用名称&quot;）用于弥补CN数量的限制，并会在将来逐渐替代Common Name，而且Chrome版本58及以上已经将SAN作为证书校验项，缺少SAN报“Subject Alternative Name Missing”错误</span><br><span class="line">****/</span><br></pre></td></tr></table></figure><p>●创建包含SAN等证书扩展信息的congzhou.ext文件，文件内容如下；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">authorityKeyIdentifier=keyid,issuer</span><br><span class="line">basicConstraints=CA:FALSE</span><br><span class="line">keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment</span><br><span class="line">subjectAltName = @alt_names</span><br><span class="line"></span><br><span class="line">[alt_names]</span><br><span class="line">DNS.1 = *.congzhou.com</span><br><span class="line">DNS.2 = localhost</span><br></pre></td></tr></table></figure><p>●使用CA证书&quot;RootCA.pem&quot;文件及证书扩展信息&quot;congzhou.ext&quot;文件给网站证书签名生成证书到&quot;congzhou.crt&quot;文件；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -days 1024 -in congzhou.csr -CA RootCA.pem -CAkey RootCA.key -CAcreateserial -extfile congzhou.ext -out congzhou.crt</span><br><span class="line"></span><br><span class="line">/******</span><br><span class="line">  * 命令解读</span><br><span class="line">  * openssl-x509用途较多，此处用于为CSR签名</span><br><span class="line">  * 参数解读</span><br><span class="line">  * -req 指明此处x509命令用于为CSR签名</span><br><span class="line">  * -CAserial 无须通过-set_serial手动指定serial number</span><br><span class="line">  * -extfile 指定CA扩展信息所在文件</span><br><span class="line">****/</span><br></pre></td></tr></table></figure><h4 id="添加对CA证书的信任"><a href="#添加对CA证书的信任" class="headerlink" title="添加对CA证书的信任"></a>添加对CA证书的信任</h4><p>♂方式1：在&quot;RootCA.crt&quot;文件的右键菜单选&quot;安装证书&quot;，&quot;证书存储&quot;选择&quot;受信任的根证书颁发机构&quot;；<br>♂方式2：运行&quot;certmgr.msc&quot;，在左侧“受信任的根证书颁发机构-&gt;证书”上右键菜单“所有任务-&gt;导入”选择RootCA.crt文件安装；<br>♂安装成功后在&quot;certmgr.msc&quot;证书管理程序中可以看到刚刚创建的本地模拟CA信息；</p><div class="img-container" style="width:80%;">  <img  src="/practice/%E6%9C%AC%E5%9C%B0%E8%87%AA%E7%AD%BE%E5%90%8DHTTPS%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/root_certificate_installed.png" class="" onerror="imgOnError(this);" data-fancybox ></div><h4 id="本地网站使用证书"><a href="#本地网站使用证书" class="headerlink" title="本地网站使用证书"></a>本地网站使用证书</h4><p>♀使用证书，以nginx为例，server段添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server_name blog.congzhou.com;</span><br><span class="line">listen 443 ssl; # ssl指定使用https</span><br><span class="line"></span><br><span class="line">ssl_certificate &quot;/certificate_path/congzhou.crt&quot;; # 网站证书</span><br><span class="line">ssl_certificate_key &quot;/certificate_path/congzhou.key&quot;; # 网站证书对应私钥</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><h3 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h3><p>▲验证1：访问本地https网站，浏览器校验通过；</p><div class="img-container" style="width:50%;">  <img  src="/practice/%E6%9C%AC%E5%9C%B0%E8%87%AA%E7%AD%BE%E5%90%8DHTTPS%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/browser_check_ok.png" class="" onerror="imgOnError(this);" data-fancybox ></div><p>▲验证2：浏览器中点开证书详情，可以看到颁发者、使用者信息，其中的SAN在&quot;使用者可选名称&quot;字段；</p><div class="img-container" style="width:50%;">  <img  src="/practice/%E6%9C%AC%E5%9C%B0%E8%87%AA%E7%AD%BE%E5%90%8DHTTPS%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/san_info.png" class="" onerror="imgOnError(this);" data-fancybox ></div><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>●<a href="https://medium.com/better-programming/trusted-self-signed-certificate-and-local-domains-for-testing-7c6e6e3f9548">How to Create Trusted Self-Signed SSL Certificates and Local Domains for Testing</a><br>●<a href="https://gist.github.com/cecilemuller/9492b848eb8fe46d462abeb26656c4f8">How to create an HTTPS certificate for localhost domains</a><br>●<a href="https://www.epson.eu/viewcon/corporatesite/kb/index/1179">Solve Errors: &quot;Subject Alternative Name Missing&quot; “NET::ERR_CERT_COMMON_NAME_INVALID” </a><br>●<a href="https://support.dnsimple.com/articles/what-is-common-name">What is the SSL Certificate Common Name</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前置知道&quot;&gt;&lt;a href=&quot;#前置知道&quot; class=&quot;headerlink&quot; title=&quot;前置知道&quot;&gt;&lt;/a&gt;前置知道&lt;/h3&gt;&lt;p&gt;○OpenSSL是为实现SSL和TLS提供支持的工具包；&lt;br&gt;○HTTPS证书只能绑定域名而不能绑定某个IP；&lt;br&gt;○1</summary>
      
    
    
    
    <category term="实践总结" scheme="https://congzhou09.github.io/categories/practice/"/>
    
    
    <category term="HTTPS" scheme="https://congzhou09.github.io/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>Fiddler抓取HTTPS包与手机包</title>
    <link href="https://congzhou09.github.io/practice/Fiddler%E6%8A%93%E5%8F%96HTTPS%E5%8C%85%E4%B8%8E%E6%89%8B%E6%9C%BA%E5%8C%85.html"/>
    <id>https://congzhou09.github.io/practice/Fiddler%E6%8A%93%E5%8F%96HTTPS%E5%8C%85%E4%B8%8E%E6%89%8B%E6%9C%BA%E5%8C%85.html</id>
    <published>2021-01-11T09:50:23.000Z</published>
    <updated>2025-03-19T13:37:34.622Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>◇Fiddler抓包基于注册成HTTP(S)协议数据的收发代理；<br>◇只要支持配置http代理的环境，就可以使用Fiddler抓包，据此可以抓取经过手机的HTTP(S)包；<br>◇HTTPS比HTTP多了非对称加密机制，包含一对互相解密的公钥和私钥，发起HTTPS过程如下图，抓取HTTPS内容除了作为代理拿到客户端与服务器之间传输的数据还需要能对数据解密；</p><div class="img-container" style="width:100%;">  <img  src="/practice/Fiddler%E6%8A%93%E5%8F%96HTTPS%E5%8C%85%E4%B8%8E%E6%89%8B%E6%9C%BA%E5%8C%85/HTTPS_connection_setup.png" class="" onerror="imgOnError(this);" data-fancybox ></div><p>◇Fiddler抓取HTTPS包借鉴中间人攻击(Man-in-the-MiddleAttack，简称MITM攻击)原理，代理服务器与客户端之间使用中间人的公钥私钥，与服务器之间使用服务器的公钥；</p><div class="img-container" style="width:90%;">  <img  src="/practice/Fiddler%E6%8A%93%E5%8F%96HTTPS%E5%8C%85%E4%B8%8E%E6%89%8B%E6%9C%BA%E5%8C%85/MITM_attack.png" class="" onerror="imgOnError(this);" data-fancybox ></div><p>◇服务器公钥包含在服务器提供的SSL证书中，除了公钥还包含:证书颁发机构(即CA)、有效期、公钥、证书持有者、CA指纹和指纹算法等。真实CA的数字证书(即根证书)由于拿不到私钥是无法伪造的，中间人需要伪造一个CA，并能随时颁发要访问任何网站的SSL证书，同时需要在系统根证书管理中添加对伪造CA根证书的信任否则浏览器会跳出安全提示；</p><h3 id="抓取HTTPS包的方法"><a href="#抓取HTTPS包的方法" class="headerlink" title="抓取HTTPS包的方法"></a>抓取HTTPS包的方法</h3><p>◇伪造一个CA并能随时颁发要访问任何服务器的SSL证书的机制Fiddler已经提供，打开Fiddler设置：Tools-&gt;Options-&gt;HTTPS-&gt;Capture HTTPS CONNECTs-&gt;Decrypt HTTPS traffic，根据提示生成名为&quot;DO_NOT_TRUST_FiddlerRoot&quot;的根证书并添加到系统信任根证书列表；</p><div class="img-container" style="width:80%;">  <img  src="/practice/Fiddler%E6%8A%93%E5%8F%96HTTPS%E5%8C%85%E4%B8%8E%E6%89%8B%E6%9C%BA%E5%8C%85/generate_root_certificate.png" class="" onerror="imgOnError(this);" data-fancybox ></div><p>◇windows下运行&quot;certmgr.msc&quot;可以查看系统当前信任的根证书列表；</p><div class="img-container" style="width:80%;">  <img  src="/practice/Fiddler%E6%8A%93%E5%8F%96HTTPS%E5%8C%85%E4%B8%8E%E6%89%8B%E6%9C%BA%E5%8C%85/root_certificates_in_system.png" class="" onerror="imgOnError(this);" data-fancybox ></div><p>◇打开Fiddler抓包开关，访问HTTPS目标网址，点开地址栏锁图标查看证书信息，可以看到其中的证书颁发组织都变成了&quot;DO_NOT_TRUST&quot;，Fiddler中此时也可查看HTTPS包内容；</p><div class="img-container" style="width:100%;">  <img  src="/practice/Fiddler%E6%8A%93%E5%8F%96HTTPS%E5%8C%85%E4%B8%8E%E6%89%8B%E6%9C%BA%E5%8C%85/certificate_change.jpg" class="" onerror="imgOnError(this);" data-fancybox ></div><h3 id="抓取手机包-包括HTTPS-的方法"><a href="#抓取手机包-包括HTTPS-的方法" class="headerlink" title="抓取手机包(包括HTTPS)的方法"></a>抓取手机包(包括HTTPS)的方法</h3><p>■如已经按上一段步骤生成根证书则直接进入下一步；<br>■设置Fiddler作为局域网代理服务器：Tools-&gt;Options-&gt;Connections</p><div class="img-container" style="width:80%;">  <img  src="/practice/Fiddler%E6%8A%93%E5%8F%96HTTPS%E5%8C%85%E4%B8%8E%E6%89%8B%E6%9C%BA%E5%8C%85/set_as_proxy_in_local_area_network.png" class="" onerror="imgOnError(this);" data-fancybox ></div><p>■手机连入与运行Fiddler的PC端相同的局域网，配置手机的局域网代理为PC局域网IP及Fiddler设置的端口；<br>■手机端安装信任证书<br>（1）手机访问网址http:&#x2F;&#x2F;<em>PC局域网IP</em>:<em>fiddler设置的端口</em>，页面内下载&quot;FiddlerRoot Certificate&quot;安装并设置系统信任；<br>（2）iOS版本高于10.3需额外操作手机：设置-&gt;通用-&gt;关于本机-&gt;证书信任设置；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;基本原理&quot;&gt;&lt;a href=&quot;#基本原理&quot; class=&quot;headerlink&quot; title=&quot;基本原理&quot;&gt;&lt;/a&gt;基本原理&lt;/h3&gt;&lt;p&gt;◇Fiddler抓包基于注册成HTTP(S)协议数据的收发代理；&lt;br&gt;◇只要支持配置http代理的环境，就可以使用Fidd</summary>
      
    
    
    
    <category term="实践总结" scheme="https://congzhou09.github.io/categories/practice/"/>
    
    
    <category term="Fiddler" scheme="https://congzhou09.github.io/tags/Fiddler/"/>
    
    <category term="HTTPS" scheme="https://congzhou09.github.io/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>浏览器内核列举</title>
    <link href="https://congzhou09.github.io/knowledge/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%88%97%E4%B8%BE.html"/>
    <id>https://congzhou09.github.io/knowledge/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%88%97%E4%B8%BE.html</id>
    <published>2020-12-25T06:48:39.000Z</published>
    <updated>2025-03-19T13:37:34.731Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>● 浏览器内核包含两种引擎：排版引擎、JS 引擎。由于 JS 引擎越来越独立，浏览器内核倾向于单指排版引擎。<br>● 排版引擎也称&quot;渲染引擎（Rendering Engine）&quot;，负责渲染网页内容的总体控制。<br>● 所有网页浏览器、电子邮件客户端以及其它需要编辑显示 HTML 内容的应用程序都需要排版引擎。</p><h3 id="排版引擎"><a href="#排版引擎" class="headerlink" title="排版引擎"></a>排版引擎</h3><p>● Trident（&#x2F;`traidnt&#x2F; 又称为 MSHTML），是 Windows 操作系统曾经搭载的 IE 浏览器所使用的排版引擎，它的第一个版本诞生于 1997 年 10 月的 Internet Explorer 第四版，2015 年微软推出的 Edge 浏览器使用的是 EdgeHTML 排版引擎，2019 年改用谷歌的 Blink。<br>● Gecko（&#x2F;`gekəʊ&#x2F;）是以 C++编写的开源排版引擎，能在 Windows、Linux 和 Mac 等主要操作系统上跨平台运行，由网景通讯公司开发，现在由 Mozilla 基金会维护，被 Mozilla 系列产品(如 Firefox 浏览器)所使用。<br>● KHTML 是自由软件项目 KDE(K Desktop Environment，基于 Qt 开发)中实现的排版引擎，最初用于 Linux 开源操作系统，苹果将 KHTML 项目 fork 到自己的 WebKit 项目并在其基础上开发并命名为 WebCore，用于 Safari 浏览器，后来 WebKit 项目也开源了，Chrome 最初的排版引擎也使用 WebCore。<br>● Presto（&#x2F;ˈprestəʊ&#x2F;）是由 Opera Software 开发的浏览器排版引擎，应用于 Opera 浏览器，Opera 后来放弃了自有排版引擎跟随 Chromium。<br>● Blink，Chrome 后来从 WebCore fork 出分支并命名为 Blink。</p><h3 id="JS-引擎"><a href="#JS-引擎" class="headerlink" title="JS 引擎"></a>JS 引擎</h3><p>◇ JScript，老版本 IE 使用，2011 年发布的 IE9 以及之后 Edge 浏览器使用 Chakra，2019 年改用谷歌的 V8。<br>◇ Monkey 系列，Firefox 使用。<br>◇ SquirrelFish 系列，Safari 使用。<br>◇ Carakan，Opera 使用。<br>◇ V8，Chrome 从第一个版本起就使用的 JS 引擎，以 C++编写的谷歌开源项目。</p><h3 id="浏览器内核（也称为浏览器引擎，包含了排版引擎和-JS-引擎）"><a href="#浏览器内核（也称为浏览器引擎，包含了排版引擎和-JS-引擎）" class="headerlink" title="浏览器内核（也称为浏览器引擎，包含了排版引擎和 JS 引擎）"></a>浏览器内核（也称为浏览器引擎，包含了排版引擎和 JS 引擎）</h3><p>● WebKit<br>（1）WebKit 是苹果的浏览器内核，始于 2001 年，于 2005 年开源，它所包含的 WebCore 排版引擎和 JavaScriptCore JS 引擎分别是从 KDE 的 KHTML 和 KJS 衍生而来。<br>（2）2008 年 WebKit 团队重写了 JS 引擎命名为 SquirrelFish，并在 Chrome 发布的两个星期后发布。<br>（3）由于宽松的协议、轻量级的设计和便捷的应用程序内嵌 API，WebKit 变得流行，除了 Google Chrome&#x2F;Chromium 和 Safari，它在移动终端（ Symbian S60，Android，iOS，Kindle）到 Toolkit 集成(GTK+, Qt4) 都有不错的收获，被统称为 WebKit。<br>● Blink<br>（1）&quot;Blink&quot;有时也作为包含 Blink 排版引擎和 V8 JS 引擎的浏览器内核的名字。<br>（2）Chrome 浏览器最初使用 WebKit 的排版引擎（即 WebCore）是 Android 团队的建议，由于谷歌与苹果的竞争关系使开源的合作无法维系，于是诞生了 Blink。<br>（3）Google 自 2013 年起在 Google Chrome&#x2F;Chromium 中使用 Blink，iOS 中的 Chrome 仍然使用的 WebCore。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;● 浏览器内核包含两种引擎：排版引擎、JS 引擎。由于 JS 引擎越来越独立，浏览器内核倾向于单指排版引擎。&lt;br&gt;● 排版引擎也称&amp;quo</summary>
      
    
    
    
    <category term="知识解惑" scheme="https://congzhou09.github.io/categories/knowledge/"/>
    
    
    <category term="浏览器" scheme="https://congzhou09.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>网页渲染过程</title>
    <link href="https://congzhou09.github.io/knowledge/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B.html"/>
    <id>https://congzhou09.github.io/knowledge/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B.html</id>
    <published>2020-12-16T02:03:54.000Z</published>
    <updated>2025-03-19T13:37:34.744Z</updated>
    
    <content type="html"><![CDATA[<h3 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h3><p>● 从 Web 内容到屏幕像素的大致过程如下图：首先 Render 进程主线程(Render 线程)上的浏览器内核实例将 HTML 及关联的 CSS 信息转换为绘制信息，然后将绘制信息交给 Compositor 线程并由 GPU 进程协助完成到屏幕像素的转换(此过程称为光栅化&lt;rasterize&gt;)；</p><div class="img-container" style="width:90%;">  <img  src="/knowledge/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/render_pipeline_general.jpg" class="" onerror="imgOnError(this);" data-fancybox ></div><p>● Render 线程和 Compositor 线程都位于浏览器的 Render 进程中。浏览器中进程与线程相关整理在这篇<a href="./%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.html">浏览器中的进程与线程</a>；<br>● Compositor 线程的&quot;合成&quot;名字源自现代浏览器实现光栅化使用的合成技术，Render 线程会将页面拆分为多个 layer ，各个 layer 将分别光栅化再合成为最终结果，这样做的优点是当页面滚动或实现动画时某些图层的上次光栅化结果可以直接使用；<br>● 渲染涉及初次渲染与更新渲染两种情况，更新渲染只有在必要的时候才进行（如 JS 操作 DOM&#x2F;CSS、用户输入、异步加载、页面滚动与缩放、动画），更新渲染时会尽可能重用上一次渲染的结果；</p><div class="img-container" style="width:90%;">  <img  src="/knowledge/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/render_cases.png" class="" onerror="imgOnError(this);" data-fancybox ></div><h3 id="初次渲染过程（以-Chrome-为例）"><a href="#初次渲染过程（以-Chrome-为例）" class="headerlink" title="初次渲染过程（以 Chrome 为例）"></a>初次渲染过程（以 Chrome 为例）</h3><p>○ <strong>构建 DOM<Document Object Model>树</strong>，Render 线程解析 HTML 生成 DOM 树，期间遇到的图片、CSS、JS 等外部资源文件会通知 Browser 进程从网络或缓存获取过来，当解析到 HTML 中的 JS 或者非延迟的 JS 文件加载完成时就暂停 DOM 解析先去执行完 JS 再返回；<br>○ <strong>构建 CSSOM<CSS Object Model>树</strong>，Render 线程再一次解析 HTML 收集各个来源(style 标签、css 文件、浏览器默认规则)的 style 规则构建成方便查找的 CSSOM 树结构；<br>○ <strong>构建 render 树</strong>，render 树来自 DOM 树与 CSSOM 树信息的合并，Render 线程遍历 DOM 树同时针对每个元素查找 CSSOM 树确定其最终 style(ComputedStyle)及当前元素是否渲染，构建出的 render 树中不包含 DOM 树中的不可见元素（如 script、meta），也不会包含 display 属性值为 none 的节点，但会包含伪元素，render 树的节点称为 RenderObject；</p><div class="img-container" style="width: 100%">  <img  src="/knowledge/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/render_tree.png" class="" onerror="imgOnError(this);" data-fancybox ></div><p>○ <strong>layout</strong>，Render 线程遍历 render 树构建 layout 树，layout 树的节点是 LayoutObject，LayoutObject 节点包含了对应 render 树节点的引用，以及经计算得出的该元素的 layout 信息（主要是 xy 坐标、所占页面空间大小等几何信息）；<br>○ <strong>layer</strong>，Render 线程遍历 layout 树，将页面拆分成多个 layer 子树；<br>○ <strong>prepaint</strong>，Render 线程创建 property 树集合记录各 layer 子树的图形图像变换属性（transform、clip、effect、scroll），每个 layer 分别进入之后的 paint 阶段；</p><div class="img-container" style="width:70%">  <img  src="/knowledge/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/property_trees.png" class="" onerror="imgOnError(this);" data-fancybox ></div><p>○ <strong>paint</strong>，Render 线程遍历 layer 子树创建描述其绘制过程的操作记录(称为 paint records)列表，由于操作记录的顺序会影响到元素重叠区域的前后遮挡关系，绘制过程会大致按照如下阶段创建绘制对象，于是每个元素通常对应多个绘制对象；</p><div class="img-container" style="40%">  <img  src="/knowledge/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/build_paint_records_phase.png" class="" onerror="imgOnError(this);" data-fancybox ></div><p>○ <strong>commit</strong>，Render 线程同步地将 layer 绘制对象列表及 property 树集合传输到 Compositor 线程，之后的步骤不再占用 Render 线程；<br>○ <strong>tiling</strong>，Compositor 线程将 layer 拆分为多个 tile，layer 所占区域可能比较大且距离当前视口较远，tile 按照优先级顺序进入 raster 阶段；<br>○ <strong>raster</strong>，GPU 进程中的 Raster 线程(Rasterizer Thread)们将各个绘制对象通过 Skia 库转换成 GL 函数的调用序列，GL 函数的调用序列执行后生成存储于 GPU 内存中的由像素颜色值组成的 bitmap；<br>○ <strong>draw</strong>，Compositor 线程收集当前视口区域内的所有 tile 的 GPU 内存地址和屏幕位置等信息(这些信息称为 draw quads)封装成一个 CompositorFrame 提交给 Browser 进程，除了 Render 进程之外，Browser 进程也同时收集来自 UI 线程、插件进程的 CompositorFrame，将它们一并交给 GPU 进程做聚合之后绘制到屏幕；</p><h3 id="更新渲染过程（以-Chrome-中的-input-事件为例）"><a href="#更新渲染过程（以-Chrome-中的-input-事件为例）" class="headerlink" title="更新渲染过程（以 Chrome 中的 input 事件为例）"></a>更新渲染过程（以 Chrome 中的 input 事件为例）</h3><p>☆ 这里的 input 事件包括针对网页区域的所有点击、输入、滚轮、鼠标移动、鼠标悬停、触摸、缩放等鼠标键盘触摸事件；<br>☆input 事件首先被 Browser 进程捕捉到，Browser 进程判断事件的坐标及所在页面，将事件及坐标信息发送给对应的 Render 进程，事件先被 Compositor 线程处理，Compositor 线程判断事件是否位于事件监听区域，如果在监听区域之外则不经过 Render 线程而由 Compositor 线程直接生成新的 CompositorFrame，否则将事件交给 Render 线程，Render 线程处理事件流及事件监听回调，之后由 Event Loop 触发 Compositor 线程生成新 CompositorFrame 的过程；</p><h3 id="要点补充"><a href="#要点补充" class="headerlink" title="要点补充"></a>要点补充</h3><p>◇ 渲染流程中的每一步结果都是基于上一步结果的，所以当上游内容有变化时，下游步骤都需要重新执行一遍；<br>◇ reflow 与 repaint<br>（1）reflow 指浏览器需要重新计算元素的几何特性，从 layout 阶段重新生成一次 CompositorFrame，引起 reflow 的操作如：改变元素的 display 属性、DOM 树增减元素、改变元素的大小或位置，详细属性如下图；</p><div class="img-container" style="width:80%">  <img  src="/knowledge/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/reflow_properties.png" class="" onerror="imgOnError(this);" data-fancybox ></div><p>（2）repaint 需要重新绘制元素，从 paint 阶段重新生成一次 CompositorFrame，引起 Repaint 的操作如：改变元素的背景色或 box-shadow；</p><div class="img-container" style="width:80%">  <img  src="/knowledge/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/repaint_properties.png" class="" onerror="imgOnError(this);" data-fancybox ></div><p>（3）reflow 过程包含 repaint；<br>（4）repaint 会 repaint 变化元素及与其属于同一个 layer 的其他元素，不会 repaint 其他 layer；<br>◇ Compositor 线程里会维护当前帧与下一帧的绘制信息，当前帧(active tree)在 draw 阶段时可以同时进行下一帧(pending tree)的 raster 阶段；</p><h3 id="网页渲染详细过程图"><a href="#网页渲染详细过程图" class="headerlink" title="网页渲染详细过程图"></a>网页渲染详细过程图</h3><div class="img-container" style="width:95%">  <img  src="/knowledge/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/render_pipeline_detail.png" class="" onerror="imgOnError(this);" data-fancybox ></div><h3 id="Chrome-相关工具"><a href="#Chrome-相关工具" class="headerlink" title="Chrome 相关工具"></a>Chrome 相关工具</h3><p>◇ 通过 Chrome 的 Layers 工具可以查看页面被分成了哪些 layer，以及每个 layer 的拆分原因和 paint 阶段的绘制对象；</p><div class="img-container" style="width:100%">  <img  src="/knowledge/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/chrome_layers_tool.png" class="" onerror="imgOnError(this);" data-fancybox ></div><p>◇ 通过 Chrome 的 Performance 工具可以查看渲染过程中 Render 线程、Raster 工作线程、GPU 进程、Compositor 线程的 timeline 及与浏览器各帧的对应关系；</p><div class="img-container" style="width:100%">  <img  src="/knowledge/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/render_threads_in_chrome_performance_tool.png" class="" onerror="imgOnError(this);" data-fancybox ></div><p>◇ 目前的拆分 layer 过程及图形图像变换属性在 paint 阶段之前由 Render 线程完成，这从目前的 Performance 里可以看到，官方计划之后将把这部分工作放到 paint 阶段后面；</p><div class="img-container" style="width:100%">  <img  src="/knowledge/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/composite_before_paint.png" class="" onerror="imgOnError(this);" data-fancybox ></div><div class="img-container" style="width:90%">  <img  src="/knowledge/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/composite_after_paint.png" class="" onerror="imgOnError(this);" data-fancybox ></div><h3 id="相关编程技巧"><a href="#相关编程技巧" class="headerlink" title="相关编程技巧"></a>相关编程技巧</h3><p>◆ 当页面元素变化时，通过避免 reflow 甚至同时避免 repaint 而只通过 Compositor 线程完成更新渲染，可以提高页面的性能，不仅因为总体运算量少，也因为 paint 之后的阶段都不在 Render 线程上进行；<br>◆ 当下主流浏览器（Chrome、Firefox、Safari、Opera）都实现了仅通过 compositing 完成 transform 与 opacity 两种 CSS 属性，极大提高了基于二者所实现页面动画(称为 compositing only animations)的流畅度，操作步骤如下：<br>（1）将动画元素提升到单独一层 layer，实现此目的的专用 CSS 属性&quot;will-change&quot;还在实验阶段，下图各方式可以更兼容地将元素提升为单独的 layer，例如：&quot;transform: translateZ(0)&quot;，这一步是下一步替代 CSS 属性的前提，即使下一步无法替代，layer 的提升也可以减少 reflow 与 repaint 的波及范围；</p><div class="img-container" style="width:70%">  <img  src="/knowledge/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/promote_layer_methods.png" class="" onerror="imgOnError(this);" data-fancybox ></div><p>（2）尽可能使用 transform 代替 left、top 等属性以及使用 opacity 属性代替 rgba 颜色值来实现等价的 CSS 动画；</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>●<a href="https://docs.google.com/presentation/d/1boPxbgNrTU0ddsc144rcXayGA_WF53k96imRH8Mp34Y/edit#slide=id.ga884fe665f_64_6">life of a pixel</a><br>●<a href="https://developers.google.com/web/updates/2018/09/inside-browser-part3">Inside look at modern web browser 系列</a><br>●<a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model">Constructing the Object Model</a><br>●<a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction">Render-tree Construction, Layout, and Paint</a><br>●<a href="https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/core/dom/README.md#flat-tree">Chromium Source Code README.md</a><br>●<a href="https://blog.logrocket.com/eliminate-content-repaints-with-the-new-layers-panel-in-chrome-e2c306d4d752/?gi=cd6271834cea">Eliminate content repaints with the new Layers panel in Chrome</a><br>●<a href="https://www.html5rocks.com/en/tutorials/speed/high-performance-animations/">High Performance Animations</a><br>●<a href="https://developers.google.com/web/fundamentals/performance/rendering/stick-to-compositor-only-properties-and-manage-layer-count">Stick to Compositor-Only Properties and Manage Layer Count</a><br>●<a href="https://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome">GPU Accelerated Compositing in Chrome</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;总览&quot;&gt;&lt;a href=&quot;#总览&quot; class=&quot;headerlink&quot; title=&quot;总览&quot;&gt;&lt;/a&gt;总览&lt;/h3&gt;&lt;p&gt;● 从 Web 内容到屏幕像素的大致过程如下图：首先 Render 进程主线程(Render 线程)上的浏览器内核实例将 HTML 及关联的</summary>
      
    
    
    
    <category term="知识解惑" scheme="https://congzhou09.github.io/categories/knowledge/"/>
    
    
    <category term="浏览器" scheme="https://congzhou09.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>浏览器中的进程与线程</title>
    <link href="https://congzhou09.github.io/knowledge/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.html"/>
    <id>https://congzhou09.github.io/knowledge/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.html</id>
    <published>2020-12-11T09:08:00.000Z</published>
    <updated>2025-03-19T13:37:34.723Z</updated>
    
    <content type="html"><![CDATA[<h3 id="浏览器中的进程"><a href="#浏览器中的进程" class="headerlink" title="浏览器中的进程"></a>浏览器中的进程</h3><p>◆ 现代浏览器都是多进程的，不过目前没有标准规范约定浏览器具体要分为哪些进程或线程，所以各浏览器厂商实现细节会有不同且随着发展在不断调整中，本文以 Chrome 浏览器为例，Chrome 的浏览器内核是 Blink；<br>◆ Chrome 主要包括如下进程：<br>（1）Browser 进程，浏览器主进程，只有一个，负责浏览器基本界面和功能（如地址栏、书签、前进后退按钮）的展示与交互、操作系统特权功能如网络请求和文件访问，以及各子进程的管理；<br>（2）Render 进程，也称为“Renderer”，通常有多个，负责网页内容相关的事务，通常说的“浏览器内核”运行在 Render 进程，默认每个 tab 页对应一个 Render 进程，当满足某些条件如 tab 页超过一定数量或系统资源紧缺时会做合并优化（比如相同网站 tab 共用一个 Render 进程甚至不同网站 tab 共用一个 Render 进程）；<br>（3）Utility 进程，有多个，用于网络、存储、音频播放等通用功能；<br>（4）GPU 进程，只有一个，集中处理 GPU 任务；<br>（5）Plugin 进程，有多个，负责在后台运行浏览器插件；</p><div class="img-container" style="width: 87%;">  <img  src="/knowledge/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/chrome_process_architecture.jpg" class="" onerror="imgOnError(this);" data-fancybox ></div><p>◆ 通过“Shift+Esc”打开浏览器的“任务管理器”可以看到当前运行的所有浏览器进程；<br>◆ 上述进程都是多线程的，而且所有进程都有两个基础线程：Main 线程和 I&#x2F;O 线程，另外可能有些做特定工作的线程，以及做通用工作的线程池；<br>◆ Browser 进程中的 Main 线程也称为 UI 线程，主要负责 UI 相关，Browser 进程中的 I&#x2F;O 线程处理 IPC（Inter-process communication 进程间通信）与网络请求；<br>◆ Render 进程中的 Main 线程也称为 Render 线程(有时也按照浏览器内核名命名如 Blink 主线程)，同样有 I&#x2F;O 线程处理 IPC；<br>◆ 几乎每个线程都有一个不断从任务队列获取要执行任务的 loop，多个线程可能共享同一个任务队列；</p><h3 id="Render-进程中的线程"><a href="#Render-进程中的线程" class="headerlink" title="Render 进程中的线程"></a>Render 进程中的线程</h3><p>◆ Render 线程会创建了一个浏览器内核实例，用于处理接收到的网页内容，它会针对每个网页建立一个 RenderView 实例，每个 RenderView 实例又会被关联到 Browser 进程中的一个 RenderViewHost 实例以便 Browser 进程的统一管理；<br>◆ Browser 进程与 Render 进程及各自主要线程的关系如下图，其中 Render 进程的线程在第一张图中不准确，以第二张图为准；</p><div class="img-container" style="width: 90%">  <img  src="/knowledge/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/chrome_thread_architecture.jpg" class="" onerror="imgOnError(this);" data-fancybox ></div><div class="img-container" style="width: 90%">  <img  src="/knowledge/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/render_process_threads.png" class="" onerror="imgOnError(this);" data-fancybox ></div><p>◆ 浏览器内核实例包含如下功能：<br>（1）排版引擎，负责将从网络获取到的网页内容数据可视化地展示到屏幕。排版引擎中包含了负责解析编译与运行 JS 代码的 JS 引擎；<br>（2）对<a href="https://html.spec.whatwg.org/#event-loop">HTML Living Standard</a>的实现，包括：事件循环(Event Loop)、任务队列（Task Queue）、各种 Worker、垃圾回收，以及 HTMLElement、setTimeout、XMLHttpRequest 等各种接口与 API；<br>◆ 浏览器内核实例为完成功能会再开启新线程，如 worker 线程(Web Workers、ServiceWorker 与 Worklets)与 internal 线程(webaudio、database、GC 等)，以及辅助页面渲染的 Compositor 线程；<br>◆ JS 引擎是内嵌在排版引擎被被动调用的，二者都在 Render 线程上执行，从而产生平时看到的“排版引擎与 JS 引擎的执行是互斥的，同一时间只能执行其中一个”的结果；<br>◆ 对于 Blink ， Event Loop 机制由 <a href="https://docs.google.com/document/d/11N2WTV3M0IkZ-kQlKWlBcwkOkKTCuLXGVNylK5E2zvc/edit#">Scheduler</a> 完成。Scheduler 实例存在于 Render 线程的上下文但又有自己的独立线程，它维护了多个按任务类型划分的任务队列，所有希望 post 给 Render 线程处理的任务(如解析 Html )都先通过调用 Scheduler 提供的 API 将任务放入对应类型的任务队列， Scheduler 会根据优先级策略及 Render 线程当前状态确定要执行哪一个任务之后再将其 post 给 Render 线程的 message loop，下图自上而下展示了此过程；</p><div class="img-container" style="86%">  <img  src="/knowledge/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/mainThreadScheduler.jpg" class="" onerror="imgOnError(this);" data-fancybox ></div><p>◆ 默认情况下 input 类任务优先级最高，其次是 Compositor 类的任务，具体优先级权重会根据策略做动态调整；<br>◆ Compositor 线程等网页渲染相关的线程在这篇<a href="./%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B.html">网页渲染过程</a>；<br>◆ JS 引擎与 Event Loop 相关整理在这篇<a href="./%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BB%84%E6%88%90%E4%B8%8EJS%E8%BF%90%E8%A1%8C%E6%97%B6%E7%8E%AF%E5%A2%83.html">浏览器组成与 JS 运行时环境</a>；</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>●<a href="https://medium.com/@thiluxan/how-web-browsers-use-process-threads-a5e560d42037">How Web Browsers Use Process &amp; Threads</a><br>●<a href="https://medium.com/swlh/how-mozilla-firefox-and-google-chrome-use-process-threads-7f17a9c79ba0">How Mozilla Firefox and Google Chrome Use Process &amp; Threads</a><br>●<a href="https://developers.google.com/web/updates/2018/09/inside-browser-part1">Google Developers: Inside Look At Modern Web Browser 系列</a><br>●<a href="https://docs.google.com/document/d/1aitSOucL0VHZa9Z2vbRJSyAIsAz24kX8LFByQ5xQnUg/edit?usp=sharing">How Blink Works</a><br>●<a href="https://www.chromium.org/developers/design-documents/multi-process-architecture">The Chromium Projects: Multi-process Architecture</a><br>●<a href="https://www.chromium.org/developers/design-documents/displaying-a-web-page-in-chrome">The Chromium Projects: How Chromium Displays Web Pages</a><br>●<a href="https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/platform/scheduler/public/event_loop.h">Chromium Source Code And Code Comments And Readme.md </a><br>●<a href="https://chromium.googlesource.com/chromium/src/+/master/docs/threading_and_tasks.md">Threading and Tasks in Chrome</a><br>●<a href="https://docs.google.com/document/d/11N2WTV3M0IkZ-kQlKWlBcwkOkKTCuLXGVNylK5E2zvc/edit#">Blink Scheduler</a><br>●<a href="https://www.zeolearn.com/magazine/javascript-how-is-callback-execution-strategy-for-promises-different-than-dom-events-callback">JavaScript: How Is Callback Execution Strategy For Promises Different Than DOM Events Callback?</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;浏览器中的进程&quot;&gt;&lt;a href=&quot;#浏览器中的进程&quot; class=&quot;headerlink&quot; title=&quot;浏览器中的进程&quot;&gt;&lt;/a&gt;浏览器中的进程&lt;/h3&gt;&lt;p&gt;◆ 现代浏览器都是多进程的，不过目前没有标准规范约定浏览器具体要分为哪些进程或线程，所以各浏览器厂商</summary>
      
    
    
    
    <category term="知识解惑" scheme="https://congzhou09.github.io/categories/knowledge/"/>
    
    
    <category term="浏览器" scheme="https://congzhou09.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
</feed>
